* And tweak the two-d PDF figures too
** Packaging up new two-d PDF figures to send to jane
#+BEGIN_SRC sh :tangle zip-figs-for-jane.sh :results verbatim
  FILES="hist-vmean-sig-00[12]5-[ON][23]*.pdf obs-combo-hist-vmean-sig.pdf obs-combo-hist-vpeak-fwhm.pdf ABC-profile-example.pdf"
  ZIPFILE=new-figs-2016-06-22.zip
  ls -l $FILES
  zip $ZIPFILE $FILES
#+END_SRC

#+RESULTS:
#+begin_example
-rw-r--r--@ 1 will  staff  327936 Jun 22 09:07 ABC-profile-example.pdf
-rw-r--r--@ 1 will  staff   51426 Jun 22 07:56 hist-vmean-sig-0015-N26584.pdf
-rw-r--r--@ 1 will  staff   45134 Jun 22 07:55 hist-vmean-sig-0015-O35007.pdf
-rw-r--r--@ 1 will  staff   44712 Jun 22 08:01 hist-vmean-sig-0025-N26584.pdf
-rw-r--r--@ 1 will  staff   42453 Jun 22 07:53 hist-vmean-sig-0025-O35007.pdf
-rw-r--r--@ 1 will  staff   34295 Jun 22 08:12 obs-combo-hist-vmean-sig.pdf
-rw-r--r--@ 1 will  staff   38597 Jun 22 08:15 obs-combo-hist-vpeak-fwhm.pdf
  adding: hist-vmean-sig-0015-N26584.pdf (deflated 27%)
  adding: hist-vmean-sig-0015-O35007.pdf (deflated 30%)
  adding: hist-vmean-sig-0025-N26584.pdf (deflated 31%)
  adding: hist-vmean-sig-0025-O35007.pdf (deflated 32%)
  adding: obs-combo-hist-vmean-sig.pdf (deflated 36%)
  adding: obs-combo-hist-vpeak-fwhm.pdf (deflated 34%)
  adding: ABC-profile-example.pdf (deflated 8%)
#+end_example

** DONE hist-vmean-sig-*
CLOSED: [2016-06-22 Wed 08:08]
+ Changed to use =magma_r= color map
+ hist-vmean-sig-00[12]5-[ON][23]*.pdf
** DONE obs-combo-hist-vmean-sig.pdf
CLOSED: [2016-06-22 Wed 08:08]
+ I had to mask out some negative weights in the [S II] case
** DONE obs-combo-hist-vpeak-fwhm.pdf
CLOSED: [2016-06-22 Wed 08:16]
** DONE ABC-profile-example again
CLOSED: [2016-06-22 Wed 09:08]
+ [X] Redid oiii-3G-AB-hist-vmean-sig with =magma_r=
+ [X] Fixed up the combo figure with Geaphic.app
+ [X] Even fixed the blurry axis numbers on underlying PNG file
* [5/5] New versions of figures with white backgrounds
+ Add one or more of the following to each graph
#+BEGIN_SRC python :eval no
  sns.set_style('whitegrid')
  sns.set_context('talk')
  sns.set_color_codes()
  sns.set_palette('magma')
#+END_SRC
** Packaging them up to send to jane
#+BEGIN_SRC sh :tangle zip-figs-for-jane.sh :results verbatim
  FILES="bright-hist-obs.pdf obs-stats-plot.pdf sim-stats-plot.pdf pos-stats-evo-O35007.pdf strucfunc-ideal.pdf ABC-profile-example.pdf"
  ZIPFILE=new-figs-2016-06-17.zip
  ls -l $FILES
  zip $ZIPFILE $FILES
#+END_SRC

#+RESULTS:
#+begin_example
-rw-r--r--@ 1 will  staff  282010 Jun 17 10:33 ABC-profile-example.pdf
-rw-r--r--@ 1 will  staff   34470 Jun 17 08:54 bright-hist-obs.pdf
-rw-r--r--@ 1 will  staff   33360 Jun 17 09:43 obs-stats-plot.pdf
-rw-r--r--@ 1 will  staff   35171 Jun 17 09:49 pos-stats-evo-O35007.pdf
-rw-r--r--@ 1 will  staff   37768 Jun 17 09:45 sim-stats-plot.pdf
-rw-r--r--@ 1 will  staff   28251 Jun 17 09:53 strucfunc-ideal.pdf
  adding: bright-hist-obs.pdf (deflated 33%)
  adding: obs-stats-plot.pdf (deflated 42%)
  adding: sim-stats-plot.pdf (deflated 36%)
  adding: pos-stats-evo-O35007.pdf (deflated 33%)
  adding: strucfunc-ideal.pdf (deflated 44%)
  adding: ABC-profile-example.pdf (deflated 9%)
#+end_example

** DONE ABC-profile-example
CLOSED: [2016-06-17 Fri 10:34]
This is combination with Graphic of:
+ [X] oiii-3G-AB-hist-vmean-sig
+ [X] A PNG file that I had to tweak by hand
** DONE bright-hist-obs
CLOSED: [2016-06-17 Fri 09:39]

** DONE obs-stats-plot and sim-stats-plot
CLOSED: [2016-06-17 Fri 09:45]

** DONE pos-stats-evo-*
CLOSED: [2016-06-17 Fri 09:50]
** DONE strucfunc-ideal
CLOSED: [2016-06-17 Fri 09:53]


* Comments on draft of sac paper [2016-04-21 Thu]
** DONE Snippet on ordered velocity dispersion
CLOSED: [2016-06-04 Sat 17:56]
Now in [[file:will-discussion-widths.tex][file:~/Dropbox/OrionStats/NewMoments/will-discussion-widths.tex]]
** DONE Changes to summary
CLOSED: [2016-06-04 Sat 17:56]
+ Put (vi) before (v)
** DONE Other fixes
CLOSED: [2016-06-04 Sat 23:52]
+ Sec 3.3, end of 2nd para.  Looks to me like large k has *steeper* slope, not shallower
** Introduction
+ Current version lifted mainly from other paper
  + 
*** New things for the introduction 
+ Cite ODH04
+ Cite Mc Leod
*** New stuff for discussion 
**** Trim down comparison with other observations

**** Is the turbulence responsible for the linewidths?
New section with my observed figures
**** New appendix with my simulation figures
* Skewness and kurtosis of brightness maps
+ For column density, this is a diagnostic of Mach number of turbulence

* Explaining the breaks in the power spectra

** Calculating P(k) from C(l)
#+BEGIN_SRC python :return plotfile :results file
  import numpy as np
  from matplotlib import pyplot as plt

  smax = 10000.0
  ns = 1024*1024*16
  s = (np.arange(ns) + 1)*smax/ns
  nk = 1 + ns//2
  k = np.arange(nk)/smax
  n = 2./3.
  Cturb = 1.0/(1.0 + s**n)
  Phi = np.abs(np.fft.rfft(Cturb))

  plotfile = 'toy-powerspec.pdf'
  fig, ax = plt.subplots(1, 1)
  ax.loglog(k, k*Phi)
  ax.loglog(k, 100*k**(-n))
  ax.loglog(k, k)
  #ax.set_ylim(1.0, 1000)
  fig.savefig(plotfile)

#+END_SRC

#+RESULTS:
[[file:toy-powerspec.pdf]]

** Looking at power spectrum from noise
#+BEGIN_SRC python :return plotfile :results file
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  nx = 512

  xmax = 250.0
  x0 = xmax/2
  dx0 = 1.8
  x = np.linspace(0, xmax, nx)
  S00 = 1.0e3 * 0.8
  nexperiment = 100
  nk = 1 + nx//2
  k = (np.arange(nk) + 1)/xmax

  xfluc0 = 5.0
  afluc = 0.15

  gsig0 = 0.15*x0


  Pstack = np.zeros((nexperiment, nk))
  Sstack = np.zeros((nexperiment, nx))
  for Prow, Srow in zip(Pstack, Sstack):
      S0 = np.random.normal(S00, 0.3*S00)
      noise = np.random.normal(0.0, 1.0, nx)
      xshift = np.random.normal(0.0, 0.3)
      # S = S0/(1. + ((x - x0*(1 + xshift))/(dx/2))**2)
      dx = dx0*np.random.normal(1.0, 0.3)
      S = S0*np.exp(-0.5*((x - x0*(1 + xshift))/(dx))**2)
      # S += 0.25*S0*np.exp(-0.5*((x - x0*(1.0 + 1.02*xshift))/(2*dx))**2)
      S += 0.5*S0*np.exp(-0.5*((x - x0*(1.0 + 0.95*xshift))/(3*dx))**2)
      xfluc = xfluc0*(1.0 + np.random.normal(0.0, 0.5))
      gsig = gsig0*np.random.normal(1.0, 0.5)
      gauss = np.exp(-0.5*((x - x0*(1 + 1.05*xshift))/gsig)**2)
      S += 0.3*S0*gauss
      S *= (1.0 + afluc*np.cos(2*np.pi*x/xfluc))
      S += noise*np.sqrt(S)
      Srow += S
      Prow += np.abs(np.fft.rfft(S))**2
  P = 10**np.mean(np.log10(Pstack), axis=0)
  dP = Pstack.std(axis=0)

  plotfile = 'fake-powerspec.pdf'
  sns.set_style('whitegrid')
  sns.set_context('talk')
  sns.set_color_codes()
  sns.set_palette('magma')
  fig, (ax, ax2) = plt.subplots(2, 1)
  for PP in Pstack:
      ax.loglog(k, k**3 * PP, lw=1, alpha=0.05)
  ax.loglog(k, k**3 * P, lw=3, color='green')
  ax.loglog(k, k**3 * P, lw=0.3, color='white', alpha=0.3)
  ax.axvline(1./(2*2.3*dx0), ls='--', color='b', alpha=0.7)
  ax.axvline(1./(3*2*2.3*dx0), ls='--', color='b', alpha=0.7)
  ax.axvline(1./(2*2.3*gsig0), ls='--', color='b', alpha=0.7)
  ax.axvline(1./xfluc0, ls=':', color='b', alpha=0.8)
  xmin, xmax = 0.004, 0.8
  # ymin, ymax = 0.33*np.min(k**3 * P), 3.0*np.max(k**3 * P)
  ymin, ymax = 200.0, 2e4
  x1, x2, x3, x4 = 1.0/100.0, 1.0/22.0, 1.0/8.0, 1.0/3.0
  ax.fill_betweenx([ymin, ymax], [x1, x1], [x2, x2],
                   color='c', alpha=0.1)
  ax.fill_betweenx([ymin, ymax], [x3, x3], [x4, x4],
                   color='c', alpha=0.2)
  ax.text(np.sqrt(x1*x2), 300.0, 'I',
          va='center', ha='center', fontsize='large')
  ax.text(np.sqrt(x2*x3), 300.0, 'II',
          va='center', ha='center', fontsize='large')
  ax.text(np.sqrt(x3*x4), 300.0, 'III',
          va='center', ha='center', fontsize='large')
  ax.text(np.sqrt(x4*xmax), 300.0, 'IV',
          va='center', ha='center', fontsize='large')
  # ax.fill_between(k, k**3 * (P - dP), k**3 * (P + dP), alpha=0.1)
  ax.set_ylabel('$k^{3} P\,(k)$')
  ax.set_xlabel('Wavenumber, $k$, 1/arcsec')
  ax.set_xlim(xmin, xmax)
  ax.set_ylim(ymin, ymax)

  for SS in Sstack[::10]:
      ax2.plot(x, SS, lw=1, alpha=0.5)
  ax2.set_ylabel('Surface brightness, $S\,(x)$')
  ax2.set_xlabel('Position, $x$, arcsec')
  ax2.set_yscale('log')
  ax2.set_ylim(3.0, 3.0e3)

  fig.set_size_inches(5, 8)
  fig.tight_layout()
  fig.savefig(plotfile, dpi=600)

#+END_SRC

#+RESULTS:
[[file:fake-powerspec.pdf]]



** Do it again but with a square wave
#+BEGIN_SRC python :return plotfile :results file
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  nx = 512

  xmax = 250.0
  x0 = xmax/2
  dx0 = 1.8
  x = np.linspace(0, xmax, nx)
  S00 = 1.0e3 * 0.5
  nexperiment = 100
  nk = 1 + nx//2
  k = (np.arange(nk) + 1)/xmax

  xfluc0 = 5.0
  afluc = 0.15

  gsig0 = 0.15*x0


  def tophat(x, x0, w, floor=1.e-4):
      """Top hat function"""
      y = np.ones_like(x)*floor
      y[np.abs(x-x0) < w/2] = 1.0
      return y

  def step(x, x0, floor=1.e-4):
      """Step function"""
      y = np.ones_like(x)*floor
      y[x < x0] = 1.0
      return y

  Pstack = np.zeros((nexperiment, nk))
  Sstack = np.zeros((nexperiment, nx))
  for Prow, Srow in zip(Pstack, Sstack):
      S0 = np.random.normal(S00, 0.3*S00)
      noise = np.random.normal(0.0, 1.0, nx)
      xshift = np.random.normal(0.0, 0.3)
      # S = S0/(1. + ((x - x0*(1 + xshift))/(dx/2))**2)
      dx = 10*dx0*np.random.normal(1.0, 0.3)
      S = S0*step(x, x0*(1.0 + xshift))
      # S = S0*tophat(x, x0*(1.0 + xshift), 2.3*dx)
      # S = S0*np.exp(-0.5*((x - x0*(1 + xshift))/(dx))**2)
      # S += S0*np.exp(-0.5*((x - x0*(1.0 + 0.95*xshift))/(3*dx))**2)
    
      xfluc = xfluc0*(1.0 + np.random.normal(0.0, 0.5))
      gsig = gsig0*np.random.normal(1.0, 0.5)
      gauss = np.exp(-0.5*((x - x0*(1 + 1.05*xshift))/gsig)**2)
      #S += 0.3*S0*gauss
      #S += noise*np.sqrt(S)
      Srow += S
      Prow += np.abs(np.fft.rfft(S))**2
  P = 10**np.mean(np.log10(Pstack), axis=0)
  P = np.nanmedian(Pstack, axis=0)
  dP = Pstack.std(axis=0)

  plotfile = 'square-powerspec.pdf'
  sns.set_style('whitegrid')
  sns.set_context('talk')
  sns.set_color_codes()
  sns.set_palette('magma')
  fig, (ax, ax2) = plt.subplots(2, 1)
  for PP in Pstack:
      ax.loglog(k, k**3 * PP, lw=1, alpha=0.05)
  ax.loglog(k, k**3 * P, lw=3, color='green')
  ax.loglog(k, k**3 * P, lw=0.3, color='white', alpha=0.3)
  ax.axvline(1./(2*2.3*dx0), ls='--', color='b', alpha=0.7)
  ax.axvline(1./(3*2*2.3*dx0), ls='--', color='b', alpha=0.7)
  ax.axvline(1./(2*2.3*gsig0), ls='--', color='b', alpha=0.7)
  ax.axvline(1./xfluc0, ls=':', color='b', alpha=0.8)
  xmin, xmax = 0.004, 0.8
  # ymin, ymax = 0.33*np.min(k**3 * P), 3.0*np.max(k**3 * P)
  ymin, ymax = 200.0, 5e4
  x1, x2, x3, x4 = 1.0/100.0, 1.0/22.0, 1.0/8.0, 1.0/3.0
  ax.fill_betweenx([ymin, ymax], [x1, x1], [x2, x2],
                   color='c', alpha=0.1)
  ax.fill_betweenx([ymin, ymax], [x3, x3], [x4, x4],
                   color='c', alpha=0.2)
  ax.text(np.sqrt(x1*x2), 300.0, 'I',
          va='center', ha='center', fontsize='large')
  ax.text(np.sqrt(x2*x3), 300.0, 'II',
          va='center', ha='center', fontsize='large')
  ax.text(np.sqrt(x3*x4), 300.0, 'III',
          va='center', ha='center', fontsize='large')
  ax.text(np.sqrt(x4*xmax), 300.0, 'IV',
          va='center', ha='center', fontsize='large')
  # ax.fill_between(k, k**3 * (P - dP), k**3 * (P + dP), alpha=0.1)
  ax.set_ylabel('$k^{3} P\,(k)$')
  ax.set_xlabel('Wavenumber, $k$, 1/arcsec')
  ax.set_xlim(xmin, xmax)
  ax.set_ylim(ymin, ymax)

  for SS in Sstack[::10]:
      ax2.plot(x, SS, lw=1, alpha=0.5)
  ax2.set_ylabel('Surface brightness, $S\,(x)$')
  ax2.set_xlabel('Position, $x$, arcsec')
  ax2.set_yscale('log')
  ax2.set_ylim(3.0, 3.0e3)

  fig.set_size_inches(5, 8)
  fig.tight_layout()
  fig.savefig(plotfile, dpi=600)

#+END_SRC

#+RESULTS:
[[file:square-powerspec.pdf]]

This had all sorts of problems at high-k, so I have abandoned it

** Power spectrum of observed profiles

** Ordered versus turbulent motions
+ The difference in mean velocity between [O I] and [O III] is 9 km/s
  + Corresponding to a \sigma = 4.5 km/s
+ The total line-of-sight \sigma is 6 km/s
+ So the turbulent and ordered velocity dispersions are roughly equal at 4.5 km/s
** TODO Look at power spectrum and PDF of MUSE data
** TODO PDF of a simple photoevaporation flow
+ Define emissivity weighted PDF
  + \phi(n) d n = \int_n^{n+dn} w d n / \int w d n
+ First assume constant velocity hemi-spherical shell
  + With n = \mu^{1/2 }
  + dV = 2 \pi R^2 h d\mu

#+BEGIN_SRC python :return plotfile :results file
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from astropy.modeling import models, fitting
  from scipy.optimize import fsolve

  mu = np.linspace(0.0, 1.0, 300)[:, None]
  r = np.linspace(1.0, 5.0, 1000)

  def f(u, r):
      return np.exp(0.25*(u**2 - 1.0)) - r*np.sqrt(u)
  u = fsolve(f, 10.0*np.ones_like(r), args=(r,))

  r = r[None, :]
  u = u[None, :]

  #den = np.sqrt(mu)/r**2
  den = np.sqrt(mu)/r**2/u
  # w = den**2 * r**2
  w = den**2 * r**2
  den0 = np.average(den, weights=w)
  s = np.log(den/den0)
  m = np.isfinite(s)

  plotfile = 'flow-denpdf.pdf'

  xmin, xmax = -4.1, 2.1
  ymin, ymax = 0.0, 1.0
  fig, ax = plt.subplots(1, 1)
  H, edges, patches = ax.hist(s[m], bins=100, range=[xmin, xmax], weights=w[m], normed=True)
  # Calculate bin centers
  x = 0.5*(edges[:-1] + edges[1:])
  # Fit Gaussian 
  g = models.Gaussian1D(amplitude=H.max(), stddev=0.5)
  fitter = fitting.LevMarLSQFitter()
  #core = H > 0.0*H.max()
  core = x > -0.5
  g = fitter(g, x[core], H[core])
  xx = np.linspace(xmin, xmax, 200)
  ax.plot(xx, g(xx), 'orange', lw=2)
  ax.text(xmin + 0.1, 0.6*ymax, r'$\rho_0 = {:.5f} \,\rho_\mathrm{{max}}$'.format(den0))
  ax.text(xmin + 0.1, 0.5*ymax, r'$\sigma_{\ln(\rho/\rho_0)} '
              + '= {:.2f}$'.format(g.stddev.value))
  ax.set_xlim(xmin, xmax)
  ax.set_ylim(ymin, ymax)
  ax.set_xlabel(r'Density : $\ln\, (\rho / \rho_0)$')
  ax.set_ylabel('Probability density')
  fig.tight_layout()
  fig.savefig(plotfile)
#+END_SRC

#+RESULTS:
[[file:flow-denpdf.pdf]]

* Plane of sky versus line of sight velocity dispersion
:LOGBOOK:
CLOCK: [2016-04-11 Mon 10:41]--[2016-04-11 Mon 23:19] => 12:38
:END:
+ In the Orion slit data, we see a strange thing:
  + The plane-of-sky variance in mean velocity is \sigma^2 \approx 10 km^2/s^2 \to \sigma \approx 3 km/s
  + The line-of-sight velocity variance from linewidth is \sigma^2 \approx 80 km^2/s^2 \to \sigma \approx 9 km/s
    + This is even after taking of generous estimates of the instrumental and thermal widths
  + In summary: *Line-of-sight velocity variations \gg plane-of-sky velocity variations*
+ So the questions are:
  1. Why is that?
  2. Do we see anything similar in our simulations?
** Plane-of-sky stats for simulations
+ Steps done on server:
  1. I have generated PPV cubes in =/fs/nil/other0/will/results-sac=
     + Using =makevcubes=
  2. Then generate maps of line moments
     + Using =ppv_to_moments.py=
  3. Finally, generate table of moment stats as function of evolution time
     + Using =moments_stats.py=
+ Then copy the files like [[file:04052012_4-POS-stats-zp-O35007.tab]] to laptop
+ And we will plot them
+ [2016-05-06 Fri] Note that =THERMAL_SIGMA= values are not necessarily realistic
  + They may be a bit on the high side, due to assuming mean mass per ion \mu = 1 instead of 1.3, and also slightly higher T than observed)
  + However, they are what were used in =makevcubes= to smooth the profiles, so they are what should be used when backing out the thermal broadening from the simulations
  + But they should *not* be used when correcting the observations for thermal broadening -- instead, estimate the thermal broadening as accurately as possible for those lines
    + E.g., O lines at 10^4 K should really have 2.236 km/s, as opposed to the 2.8 km/s we have here

#+name: plot-pos-stats
#+header: :var EMLINE="O35007"
#+BEGIN_SRC python :return plotfile :results file
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from astropy.table import Table
  from cycler import cycler
  import matplotlib as mpl
  mpl.rcParams['mathtext.fontset'] = 'stix'


  THERMAL_SIGMA = {'O35007': 2.8, 'N26584': 3.1}
  VIEWS = ['xn', 'yn', 'zn', 'xp', 'yp', 'zp']
  PATTERN = '04052012_4-POS-stats-{}-{}.tab'
  PLOTVARS = ['vmean', 'd vmean', 'vsig', 'd vsig']
  LABELS = {
      'xn': '$-x$', 'xp': '$+x$',
      'yn': '$-y$', 'yp': '$+y$',
      'zn': '$-z$', 'zp': '$+z$',
      'vmean': ['Plane-of-sky average\nof line centroid: ',
                '$\\langle \\overline{u} \\rangle_\\mathrm{pos}$'],
      'd vmean': ['Plane-of-sky std. dev.\nof line centroid: ',
                  '$\\sigma_\\mathrm{pos} ( \\overline{u} )$'],
      'vsig': ['Plane-of-sky average\nof RMS line width: ',
               '$\\langle \\sigma_{\\mathrm{los}} \\rangle_\\mathrm{pos}$'],
      'd vsig': ['Plane-of-sky std. dev.\nof RMS line width: ',
                 '$\\sigma_\\mathrm{pos} ( \\sigma_{\\mathrm{los}})$'],
      'O35007': '[O III] $\lambda$5007', 'N26584': '[N II] $\lambda$6583', 
  }
  LIMITS = {
      'vmean': [-10.0, 14.0], 'd vmean': [0.0, 11.0], 'vsig': [0.0, 11.0], 'd vsig': [0.0, 11.0]
  }

  COLOR_CYCLE = cycler(color=['r', 'm', 'y'])
  ALPHA_CYCLE = cycler(alpha=[1.0, 0.5])
  LW_CYCLE = cycler(lw=[2.0, 3.0])
  STYLE_CYCLE = (ALPHA_CYCLE + LW_CYCLE) * COLOR_CYCLE

  data = {}
  for vv in VIEWS:
      data[vv] = Table.read(PATTERN.format(vv, EMLINE), format='ascii.tab')
      # Correct line widths for thermal broadening
      data[vv]['vsig'] = np.sqrt(data[vv]['vsig']**2 - THERMAL_SIGMA[EMLINE]**2)


  sns.set_color_codes("dark")
  sns.set_style('whitegrid')

  fig, axx = plt.subplots(2, 2, sharex=True)
  whitebox = {'fc': 'white', 'ec': 'none', 'boxstyle': 'round,pad=0.02'}
  for ax, var in zip(axx.flat, PLOTVARS):
  #    ax.set_title(LABELS[var])
      for vv, sty in zip(VIEWS, STYLE_CYCLE):
          ax.plot(data[vv]['time']/100.0, data[vv][var], label=LABELS[vv], **sty)
      ax.set_xlim(0.0, 0.3)
      ax.set_ylim(*LIMITS[var])
      ax.text(0.02, 0.98, LABELS[var][0], ha='left', va='top', transform=ax.transAxes, fontsize='small', bbox=whitebox)
      ax.text(0.95, 0.9, LABELS[var][1], ha='right', va='top', transform=ax.transAxes, fontsize='large', bbox=whitebox)
      ax.text(0.4, 0.025, LABELS[EMLINE], transform=ax.transAxes)
      ax.set_xticks([0.0, 0.1, 0.2, 0.3])
  for ax in axx[:, 0]:
      ax.set_ylabel('km/s')
  for ax in axx[-1, :]:
      ax.set_xlabel('Age, Myr')
  leg = axx[1, 1].legend(ncol=2, loc='center', frameon=True, framealpha=0.8)
  leg.get_frame().set_facecolor('white')

  plotfile = 'pos-stats-evo-{}.pdf'.format(EMLINE)
  fig.set_size_inches(5.5, 5.5)
  fig.tight_layout()
  fig.savefig(plotfile)

#+END_SRC

#+RESULTS: plot-pos-stats
[[file:pos-stats-evo-O35007.pdf]]

#+call: plot-pos-stats(EMLINE="N26584") :results file

#+RESULTS:
[[file:pos-stats-evo-N26584.pdf]]
** Two-d histograms of SIMULATION centroid velocity versus rms line width
#+name: hist-vmean-sig
#+header: :var EMLINE="O35007" TIME=30 CMAP="BuPu"
#+BEGIN_SRC python :return plotfile :results file
  import numpy as np
  from matplotlib import pyplot as plt
  from matplotlib.colors import PowerNorm
  import seaborn as sns
  from astropy.io import fits

  TEMPLATE = '04052012_4_{:04d}vsum-{}-{}.fits'
  VIEWS = ['xn', 'xp', 'yn', 'yp', 'zn', 'zp']
  VLIMITS = [-19.0, 19.0]
  WLIMITS = [0.0, 19.0]
  NORM = PowerNorm(gamma=0.6)
  LABELS = {
      'xn': '$-x$', 'xp': '$+x$',
      'yn': '$-y$', 'yp': '$+y$',
      'zn': '$-z$', 'zp': '$+z$',
      'O35007': '[O III] $\lambda$5007', 'N26584': '[N II] $\lambda$6583', 
      }
  sns.set_style('whitegrid')
  sns.set_color_codes("deep")
  fig, axx = plt.subplots(3, 2, sharex=True, sharey=True)
  for vv, ax in zip(VIEWS, axx.flat):
      fn = TEMPLATE.format(TIME, vv, EMLINE)
      s = fits.open(fn)[0].data.ravel()
      v = fits.open(fn.replace('vsum', 'vmean'))[0].data.ravel()
      w = fits.open(fn.replace('vsum', 'vsig'))[0].data.ravel()
      m = (v > VLIMITS[0]) & (v < VLIMITS[1])
      m = m & (w > WLIMITS[0]) & (w < WLIMITS[1])
      ax.hist2d(v[m], w[m], weights=s[m], bins=50, range=[VLIMITS, WLIMITS], cmap=CMAP, normed=True, norm=NORM)
      ax.text(0.0, 1.0, LABELS[vv], ha='center', va='baseline')
      ax.set_xticks([-10, 0, 10])
  axx[-1, 0].set_xlabel(r'Mean velocity, $\overline{u}$, km/s')
  axx[-1, 0].set_ylabel(r'RMS line width, $\sigma_{\mathrm{los}}$, km/s')
  plotfile = 'hist-vmean-sig-{:04d}-{}.pdf'.format(TIME, EMLINE)

  fig.suptitle(LABELS[EMLINE] + ' $t = {:.3f}$ Myr'.format(TIME/100.0))
  fig.set_size_inches(3, 4.5)
  fig.subplots_adjust(left=0.18, right=0.98,
                      bottom=0.12, top=0.99,
                      wspace=0.03, hspace=0.03)
  #fig.tight_layout(pad = 0.0, h_pad=0.05, w_pad=0.05)
  fig.savefig(plotfile)

#+END_SRC

#+call: hist-vmean-sig(TIME=25, CMAP="magma_r") :results file

#+RESULTS:
[[file:hist-vmean-sig-0025-O35007.pdf]]

#+call: hist-vmean-sig(EMLINE="N26584", TIME=25, CMAP="magma_r") :results file

#+RESULTS:
[[file:hist-vmean-sig-0025-N26584.pdf]]


#+call: hist-vmean-sig(TIME=15, CMAP="magma_r") :results file

#+RESULTS:
[[file:hist-vmean-sig-0015-O35007.pdf]]

#+call: hist-vmean-sig(EMLINE="N26584", TIME=15, CMAP="magma_r") :results file

#+RESULTS:
[[file:hist-vmean-sig-0015-N26584.pdf]]


#+BEGIN_SRC sh
open hist-vmean-sig-00[12]5-[ON][23]*.pdf
#+END_SRC

#+RESULTS:

*** Effects of dust scattering on line widths
From the calculation in apple notes
+ Plane parallel layer with velocity u_0 and inclined by \mu_0
+ Direct intensity: I_0 with velocity v_0 = -\mu_0 u_0  
+ Scattered intensity: I_1 with velocity v_1 = -\alpha v_0
  + where \alpha = |\mu_1|/\mu_0
  + and \mu_1 is average cosine of incidence on scattering layer
  + So range of [0 .. 1] for \alpha, probably closer to \alpha = 0
+ A fraction s of the total emission is scattered: s = I_1 / (I_0 + I_1)
+ Change in mean velocity is
  + \[ \bar{v} = \bigl( 1 - (1 + \alpha) s \bigr) v_{0} \]
+ Additional broadening is
  + \[ \sigma = (1 + \alpha) \sqrt{s (1 - s)} v_{0} \]
+ Try it out on the simulated [O III] line for -z view

#+name: hist-vmean-sig-scat
#+header: :var EMLINE="O35007" TIME=15 VIEW="zn"
#+header: :var ALPHA=0.0 SCATFRAC=0.30
#+BEGIN_SRC python :return plotfile :results file
  import numpy as np
  from matplotlib import pyplot as plt
  from matplotlib.colors import PowerNorm
  import seaborn as sns
  from astropy.io import fits

  TEMPLATE = '04052012_4_{:04d}vsum-{}-{}.fits'
  VLIMITS = [-19.0, 19.0]
  WLIMITS = [0.0, 19.0]
  CMAP = 'BuPu'
  NORM = PowerNorm(gamma=0.6)
  LABELS = {
      'xn': '$-x$', 'xp': '$+x$',
      'yn': '$-y$', 'yp': '$+y$',
      'zn': '$-z$', 'zp': '$+z$',
      'O35007': '[O III] $\lambda$5007', 'N26584': '[N II] $\lambda$6583', 
      }
  sns.set_color_codes("deep")
  fig, ax = plt.subplots(1, 1)
  fn = TEMPLATE.format(TIME, VIEW, EMLINE)
  s = fits.open(fn)[0].data.ravel()
  v = fits.open(fn.replace('vsum', 'vmean'))[0].data.ravel()
  w = fits.open(fn.replace('vsum', 'vsig'))[0].data.ravel()
  m = (v > VLIMITS[0]) & (v < VLIMITS[1])
  m = m & (w > WLIMITS[0]) & (w < WLIMITS[1])

  sig_scat = (1.0 + ALPHA)*np.sqrt(SCATFRAC*(1.0 - SCATFRAC))*v
  w = np.sqrt(w**2 + sig_scat**2)
  v = (1.0 - (1.0 + ALPHA)*SCATFRAC)*v

  ax.hist2d(v[m], w[m], weights=s[m], bins=50, range=[VLIMITS, WLIMITS], cmap=CMAP, normed=True, norm=NORM)
  ax.text(0.0, 1.0, LABELS[VIEW], ha='center', va='baseline')

  ax.set_xlabel('Centroid velocity, $\overline{u}$, km/s')
  ax.set_ylabel('RMS line width, $\sigma$, km/s')
  ax.set_title(LABELS[EMLINE] + ' $t = {:.3f}$ Myr'.format(TIME/100.0))

  plotfile = 'hist-vmean-sig-scat-{:04d}-{}-{}.pdf'.format(TIME, EMLINE, VIEW)

  fig.set_size_inches(3, 3)
  fig.tight_layout(pad = 0.2, h_pad=0.05, w_pad=0.05)
  fig.savefig(plotfile)

#+END_SRC

#+RESULTS: hist-vmean-sig-scat
[[file:hist-vmean-sig-scat-0015-O35007-zn.pdf]]

+ Now we will try the same, except allow SCATFRAC to vary from pixel to pixel
  + Take gaussian distribution, centered on 0.30

#+name: hist-vmean-sig-scat-random
#+header: :var EMLINE="O35007" TIME=15 VIEW="zn"
#+header: :var ALPHA=0.5 SCATFRAC=0.15 JITTER_SCALE=0.15
#+BEGIN_SRC python :return plotfile :results file
  import numpy as np
  from matplotlib import pyplot as plt
  from matplotlib.colors import PowerNorm
  import seaborn as sns
  from astropy.io import fits

  TEMPLATE = '04052012_4_{:04d}vsum-{}-{}.fits'
  VLIMITS = [-19.0, 19.0]
  WLIMITS = [0.0, 19.0]
  CMAP = 'BuPu'
  NORM = PowerNorm(gamma=0.6)
  LABELS = {
      'xn': '$-x$', 'xp': '$+x$',
      'yn': '$-y$', 'yp': '$+y$',
      'zn': '$-z$', 'zp': '$+z$',
      'O35007': '[O III] $\lambda$5007', 'N26584': '[N II] $\lambda$6583', 
      }
  sns.set_color_codes("deep")
  fig, ax = plt.subplots(1, 1)
  fn = TEMPLATE.format(TIME, VIEW, EMLINE)
  s = fits.open(fn)[0].data.ravel()
  v = fits.open(fn.replace('vsum', 'vmean'))[0].data.ravel()
  w = fits.open(fn.replace('vsum', 'vsig'))[0].data.ravel()
  jitter = np.random.standard_normal(size=s.shape)
  scatfrac = SCATFRAC*10**(JITTER_SCALE*jitter)
  m = (v > VLIMITS[0]) & (v < VLIMITS[1])
  m = m & (w > WLIMITS[0]) & (w < WLIMITS[1])
  
  sig_scat = (1.0 + ALPHA)*np.sqrt(scatfrac*(1.0 - scatfrac))*v
  w = np.sqrt(w**2 + sig_scat**2)
  v = (1.0 - (1.0 + ALPHA)*scatfrac)*v

  ax.hist2d(v[m], w[m], weights=s[m], bins=50, range=[VLIMITS, WLIMITS], cmap=CMAP, normed=True, norm=NORM)
  ax.text(0.0, 1.0, LABELS[VIEW], ha='center', va='baseline')

  ax.set_xlabel('Centroid velocity, $\overline{u}$, km/s')
  ax.set_ylabel('RMS line width, $\sigma$, km/s')
  ax.set_title(LABELS[EMLINE] + ' $t = {:.3f}$ Myr'.format(TIME/100.0))

  plotfile = 'hist-vmean-sig-scat-random-{:04d}-{}-{}.pdf'.format(TIME, EMLINE, VIEW)

  fig.set_size_inches(3, 3)
  fig.tight_layout(pad = 0.2, h_pad=0.05, w_pad=0.05)
  fig.savefig(plotfile)

#+END_SRC

#+RESULTS: hist-vmean-sig-scat-random
[[file:hist-vmean-sig-scat-random-0015-O35007-zn.pdf]]
*** Plot of intensity versus sigma
+ To try and spot evidence for an expanding shell
+ This is inspired by the discussion in Javier García thesis
  + References Bordalo (2009) and Muñoz-Tuñon (1996)
#+name: hist-bright-sig
#+header: :var EMLINE="O35007" TIME=30
#+BEGIN_SRC python :return plotfile :results file
  import numpy as np
  from matplotlib import pyplot as plt
  from matplotlib.colors import PowerNorm
  import seaborn as sns
  from astropy.io import fits

  TEMPLATE = '04052012_4_{:04d}vsum-{}-{}.fits'
  VIEWS = ['xn', 'xp', 'yn', 'yp', 'zn', 'zp']
  VLIMITS = [-19.0, 19.0]
  WLIMITS = [0.0, 19.0]
  SLIMITS = [5.0, 7.5]
  CMAP = 'BuPu'
  NORM = PowerNorm(gamma=0.6)
  LABELS = {
      'xn': '$-x$', 'xp': '$+x$',
      'yn': '$-y$', 'yp': '$+y$',
      'zn': '$-z$', 'zp': '$+z$',
      'O35007': '[O III] $\lambda$5007', 'N26584': '[N II] $\lambda$6583', 
      }
  sns.set_color_codes("deep")
  fig, axx = plt.subplots(3, 2, sharex=True, sharey=True)
  for vv, ax in zip(VIEWS, axx.flat):
      fn = TEMPLATE.format(TIME, vv, EMLINE)
      s = fits.open(fn)[0].data.ravel()
      v = fits.open(fn.replace('vsum', 'vmean'))[0].data.ravel()
      w = fits.open(fn.replace('vsum', 'vsig'))[0].data.ravel()
      m = (v > VLIMITS[0]) & (v < VLIMITS[1])
      m = m & (w > WLIMITS[0]) & (w < WLIMITS[1])
      ax.hist2d(np.log10(s[m]), w[m], weights=s[m], bins=50, range=[SLIMITS, WLIMITS], cmap=CMAP, normed=True, norm=NORM)
      ax.text(0.0, 1.0, LABELS[vv], ha='center', va='baseline')
  axx[-1, 0].set_xlabel('$\log_{10}$ Emission brightness')
  axx[-1, 0].set_ylabel('RMS line width, $\sigma$, km/s')
  plotfile = 'hist-bright-sig-{:04d}-{}.pdf'.format(TIME, EMLINE)

  fig.suptitle(LABELS[EMLINE] + ' $t = {:.3f}$ Myr'.format(TIME/100.0))
  fig.set_size_inches(4, 6)
  fig.tight_layout(pad = 0.2, h_pad=0.05, w_pad=0.05)
  fig.savefig(plotfile)

#+END_SRC

#+RESULTS: hist-bright-sig
[[file:hist-bright-sig-0030-O35007.pdf]]

#+call: hist-bright-sig(TIME=10) :results file

#+RESULTS:
[[file:hist-bright-sig-0010-O35007.pdf]]

#+call: hist-bright-sig(TIME=15) :results file

#+RESULTS:
[[file:hist-bright-sig-0015-O35007.pdf]]

#+call: hist-bright-sig(TIME=20) :results file

#+RESULTS:
[[file:hist-bright-sig-0020-O35007.pdf]]

#+call: hist-bright-sig(EMLINE="N26584", TIME=10) :results file

#+RESULTS:
[[file:hist-bright-sig-0010-N26584.pdf]]

#+call: hist-bright-sig(EMLINE="N26584", TIME=20) :results file

#+RESULTS:
[[file:hist-bright-sig-0020-N26584.pdf]]

#+call: hist-bright-sig(EMLINE="N26584", TIME=30) :results file

#+RESULTS:
[[file:hist-bright-sig-0030-N26584.pdf]]

#+call: hist-bright-sig(EMLINE="N26584", TIME=15) :results file

#+RESULTS:
[[file:hist-bright-sig-0015-N26584.pdf]]

** Two-d histograms of OBSERVED centroid velocity versus rms line width

Now do the same thing, but for the observational data
#+name: obs-hist-mean-sig
#+header: :var EMLINE="oiii"
#+BEGIN_SRC python :return plotfile :results file
  import numpy as np
  from matplotlib import pyplot as plt
  from matplotlib.colors import PowerNorm
  import seaborn as sns
  from astropy.io import fits

  VLIMITS = [-19.0, 19.0]
  WLIMITS = [0.0, 19.0]
  CMAP = 'BuPu'
  NORM = PowerNorm(gamma=0.6)
  DATASET = {'siil': 'spm', 'siis': 'spm',
             'siii': 'spm', 'oi': 'spm',
             'ha': 'kpno', 'nii': 'kpno', 'oiii': 'kpno'}
  TEMPLATES = {
      'kpno': '/Users/will/Work/BobKPNO/DOH{}_-040+070.wisomom-sum-xx.fits',
      'spm': '/Users/will/Work/BobKPNO/newmapas/{}_-040+070.wisomom-sum-smooth2d.fits'
  }

  LABELS = {
      'oiii': r'[O III] $\lambda$5007',
      'nii': r'[N II] $\lambda$6583',
      'ha': r'H$\alpha$ $\lambda$6563',
      'siil': r'[S II] $\lambda$6731',
      'siis': r'[S II] $\lambda$6716',
      'siii': r'[S III] $\lambda$6312',
      'oi': r'[O I] $\lambda$6300',
  }

  THERMAL_SIGMA = {'oiii': 2.8, 'nii': 3.1, 'ha': 9.1,
                   'siil': 2.0, 'siis': 2.0, 'siii': 2.0, 'oi': 2.8}
  FS_SIGMA = {'ha': 3.2}
  sns.set_color_codes("deep")
  fig, ax = plt.subplots(1, 1)

  dataset = DATASET[EMLINE]
  fn = TEMPLATES[dataset].format(EMLINE)
  s = fits.open(fn)[0].data.ravel()
  v = fits.open(fn.replace('sum', 'mean'))[0].data.ravel()
  # Subtract off mean velocity of star cluster
  v -= 25.0
  w = fits.open(fn.replace('sum', 'sigma'))[0].data.ravel()
  # Subtract off instrumental width: 8 km/s FWHM and thermal width
  w = np.sqrt(w**2 - (8/2.3)**2 - THERMAL_SIGMA[EMLINE]**2 - FS_SIGMA.get(EMLINE, 0.0)**2)
  ax.hist2d(v, w, weights=s, bins=50, range=[VLIMITS, WLIMITS], cmap=CMAP, norm=NORM)
  ax.set_xlabel('Mean velocity, $\overline{u}$, km/s')
  ax.set_ylabel('RMS line width, $\sigma$, km/s')
  ax.set_title(LABELS[EMLINE] + ' observations')
  plotfile = 'obs-hist-vmean-sig-{}.pdf'.format(EMLINE)

  fig.set_size_inches(3, 3)
  fig.tight_layout()
  fig.savefig(plotfile)



#+END_SRC

#+RESULTS: obs-hist-mean-sig
[[file:obs-hist-vmean-sig-oiii.pdf]]

#+call: obs-hist-mean-sig(EMLINE="nii") :results file

#+RESULTS:
[[file:obs-hist-vmean-sig-nii.pdf]]

#+call: obs-hist-mean-sig(EMLINE="ha") :results file

#+RESULTS:
[[file:obs-hist-vmean-sig-ha.pdf]]

#+call: obs-hist-mean-sig(EMLINE="siil") :results file

#+RESULTS:
[[file:obs-hist-vmean-sig-siil.pdf]]

#+call: obs-hist-mean-sig(EMLINE="siis") :results file

#+RESULTS:
[[file:obs-hist-vmean-sig-siis.pdf]]

#+call: obs-hist-mean-sig(EMLINE="siii") :results file

#+RESULTS:
[[file:obs-hist-vmean-sig-siii.pdf]]

#+call: obs-hist-mean-sig(EMLINE="oi") :results file

#+RESULTS:
[[file:obs-hist-vmean-sig-oi.pdf]]


** Combined graph and statistics of all the observed emission lines

#+name: obs-combo-mean-sig
#+BEGIN_SRC python :return plotfile :results file
  import numpy as np
  from matplotlib import pyplot as plt
  from matplotlib.colors import PowerNorm
  import seaborn as sns
  from astropy.io import fits
  from astropy.table import Table


  #EMLINES = ['oi', 'siil', 'nii', 'siii', 'ha', 'oiii']
  EMLINES = ['siil', 'nii', 'ha', 'oiii']
  VLIMITS = [-19.0, 19.0]
  WLIMITS = [0.0, 19.0]
  CMAP = 'magma_r'
  NORM = PowerNorm(gamma=0.6)
  DATASET = {'siil': 'spm', 'siis': 'spm',
             'siii': 'spm', 'oi': 'spm',
             'ha': 'kpno', 'nii': 'kpno', 'oiii': 'kpno'}
  TEMPLATES = {
      'kpno': '/Users/will/Work/BobKPNO/DOH{}_-040+070.wisomom-sum-xx.fits',
      'spm': '/Users/will/Work/BobKPNO/newmapas/{}_-040+070.wisomom-sum-smooth2d.fits'
  }

  LABELS = {
      'oiii': r'[O III] $\lambda$5007',
      'nii': r'[N II] $\lambda$6583',
      'ha': r'H$\alpha$ $\lambda$6563',
      'siil': r'[S II] $\lambda$6731',
      'siis': r'[S II] $\lambda$6716',
      'siii': r'[S III] $\lambda$6312',
      'oi': r'[O I] $\lambda$6300',
  }

  THERMAL_SIGMA = {'oiii': 9.0/4, 'nii': 9.0/np.sqrt(14.0), 'ha': 9.0,
                   'siil': 9.0/np.sqrt(32.0), 'siis': 9.0/np.sqrt(32.0), 
                   'siii': 9.0/np.sqrt(32.0), 'oi': 9.0/4}
  FS_SIGMA = {'ha': 3.2}

  statscolumns = ['emline',
                  'sig(los)', 'sig(pos)', 'V(los)',
                  'sig(los) uw', 'sig(pos) uw', 'V(los) uw',
  ]
  statsdict = {k: [] for k in statscolumns} 

  sns.set_color_codes("deep")
  sns.set_style('whitegrid')
  fig, axes = plt.subplots(2, 2, sharex=True, sharey=True)
  for emline, ax in zip(EMLINES, axes.flat):
      dataset = DATASET[emline]
      fn = TEMPLATES[dataset].format(emline)
      s = fits.open(fn)[0].data.ravel()
      v = fits.open(fn.replace('sum', 'mean'))[0].data.ravel()
      # Subtract off mean velocity of star cluster
      v -= 25.0
      w = fits.open(fn.replace('sum', 'sigma'))[0].data.ravel()
      # Subtract off instrumental width: 8 km/s FWHM and thermal width
      w = np.sqrt(w**2
                  - (8/2.3)**2
                  - THERMAL_SIGMA[emline]**2
                  - FS_SIGMA.get(emline, 0.0)**2)
      m = (VLIMITS[0] < v) & (v < VLIMITS[1])
      m = m & (WLIMITS[0] < w) & (w < WLIMITS[1])
      m = m & (s > 0.0)
      ax.hist2d(v[m], w[m], weights=s[m], bins=50,
                range=[VLIMITS, WLIMITS],
                cmap=CMAP,
                cmin=0.0,
                # norm=NORM,
      )
      ax.text(0.0, 15.0, LABELS[emline])

      statsdict['emline'].append(emline)
      statsdict['sig(los)'].append(np.average(w[m], weights=s[m]))
      statsdict['sig(los) uw'].append(np.average(w[m], weights=None))
      vmean = np.average(v[m], weights=s[m])
      dvsq = np.average((v[m] - vmean)**2, weights=s[m])
      statsdict['sig(pos)'].append(np.sqrt(dvsq))
      statsdict['V(los)'].append(vmean)
      vmean = np.average(v[m], weights=None)
      dvsq = np.average((v[m] - vmean)**2, weights=None)
      statsdict['sig(pos) uw'].append(np.sqrt(dvsq))
      statsdict['V(los) uw'].append(vmean)

  axes[-1,0].set_xlabel('Mean velocity, $\overline{u}$, km/s')
  axes[-1,0].set_ylabel(r'RMS line width, $\sigma_{\mathrm{los}}$, km/s')
  plotfile = 'obs-combo-hist-vmean-sig.pdf'

  fig.set_size_inches(5, 5)
  fig.tight_layout(pad = 0.2, h_pad=0.2, w_pad=0.5)
  fig.savefig(plotfile)

  Table(statsdict, names=statscolumns).write('obs-stats.tab', format='ascii.tab')

#+END_SRC

#+RESULTS: obs-combo-mean-sig
[[file:obs-combo-hist-vmean-sig.pdf]]


** Repeat previous combo graph but for observed FWHM
#+name: obs-combo-vpeak-fwhm
#+BEGIN_SRC python :return plotfile :results file
  import numpy as np
  from matplotlib import pyplot as plt
  from matplotlib.colors import PowerNorm
  import seaborn as sns
  from astropy.io import fits
  from astropy.table import Table


  #EMLINES = ['oi', 'siil', 'nii', 'siii', 'ha', 'oiii']
  EMLINES = ['siil', 'nii', 'ha', 'oiii']
  VLIMITS = [-19.0, 19.0]
  WLIMITS = [0.0, 19.0]
  CMAP = 'magma_r'
  DATASET = {'siil': 'spm', 'siis': 'spm',
             'siii': 'spm', 'oi': 'spm',
             'ha': 'kpno', 'nii': 'kpno', 'oiii': 'kpno'}
  TEMPLATES = {
      'kpno': '/Users/will/Work/BobKPNO/DOH{}_-040+070.wisomom-sum-xx.fits',
      'spm': '/Users/will/Work/BobKPNO/newmapas/{}_-040+070.wisomom-sum-smooth2d.fits'
  }

  LABELS = {
      'oiii': r'[O III] $\lambda$5007',
      'nii': r'[N II] $\lambda$6583',
      'ha': r'H$\alpha$ $\lambda$6563',
      'siil': r'[S II] $\lambda$6731',
      'siis': r'[S II] $\lambda$6716',
      'siii': r'[S III] $\lambda$6312',
      'oi': r'[O I] $\lambda$6300',
  }

  ATWT = {'h': 1, 'o': 16, 'n': 14, 's': 32}
  T4 = 0.96

  statscolumns = ['emline',
                  'sig(los)', 'sig(pos)', 'V(los)',
                  'sig(los) uw', 'sig(pos) uw', 'V(los) uw',
  ]
  statsdict = {k: [] for k in statscolumns} 

  sns.set_style('whitegrid')
  sns.set_color_codes("deep")
  fig, axes = plt.subplots(2, 2, sharex=True, sharey=True)
  for emline, ax in zip(EMLINES, axes.flat):
      dataset = DATASET[emline]
      fn = TEMPLATES[dataset].format(emline)
      s = fits.open(fn)[0].data.ravel()
      v = fits.open(fn.replace('sum', 'peak'))[0].data.ravel()
      # Subtract off mean velocity of star cluster
      v -= 25.0
      w = fits.open(fn.replace('sum', 'fwhm'))[0].data.ravel()
      # These data NOT had the thermal and instrumental widths subtracted
      # So we do that - and in FWHM units
      w_ins = 8.0
      w_th = 21.4*np.sqrt(T4/ATWT[emline[0]])
      w = np.sqrt(w**2 - w_th**2 - w_ins**2)
      # The it remains to convert from FWHM to Gauss-equivalent sigma
      w /= 2*np.sqrt(2*np.log(2))

      m = (VLIMITS[0] < v) & (v < VLIMITS[1])
      m = m & (WLIMITS[0] < w) & (w < WLIMITS[1])
      m = m & (s > 0.0)
      # But also use sigma as rejection criterion
      ww = fits.open(fn.replace('sum', 'sigma'))[0].data.ravel()
      m = m & (WLIMITS[0] < ww) & (ww < WLIMITS[1])
      ax.hist2d(v[m], w[m], weights=s[m], bins=50,
                range=[VLIMITS, WLIMITS],
                cmap=CMAP,
                #norm=PowerNorm(gamma=0.6),
      )
      ax.text(0.0, 15.0, LABELS[emline])

      statsdict['emline'].append(emline)
      statsdict['sig(los)'].append(np.average(w[m], weights=s[m]))
      statsdict['sig(los) uw'].append(np.average(w[m], weights=None))
      vmean = np.average(v[m], weights=s[m])
      dvsq = np.average((v[m] - vmean)**2, weights=s[m])
      statsdict['sig(pos)'].append(np.sqrt(dvsq))
      statsdict['V(los)'].append(vmean)
      vmean = np.average(v[m], weights=None)
      dvsq = np.average((v[m] - vmean)**2, weights=None)
      statsdict['sig(pos) uw'].append(np.sqrt(dvsq))
      statsdict['V(los) uw'].append(vmean)

  axes[-1,0].set_xlabel(r'Peak velocity, $\hat{u}$, km/s')
  axes[-1,0].set_ylabel('Equivalent RMS line width\n from FWHM, $\\hat{\\sigma}_{\\mathrm{los}}$, km/s')
  plotfile = 'obs-combo-hist-vpeak-fwhm.pdf'

  fig.set_size_inches(5, 5)
  fig.tight_layout(pad = 0.2, h_pad=0.2, w_pad=0.5)
  fig.savefig(plotfile)

  Table(statsdict, names=statscolumns).write('obs-stats-fwhm.tab', format='ascii.tab')

#+END_SRC

#+RESULTS: obs-combo-vpeak-fwhm
[[file:obs-combo-hist-vpeak-fwhm.pdf]]

** Graph of observed plane-of-sky versus line-of-sight sigmas
#+BEGIN_SRC python :results file :return plotfile
  from astropy.table import Table, hstack, join
  import numpy as np
  from matplotlib import pyplot as plt
  from matplotlib import cm
  import seaborn as sns

  labels = {
      'siil': '[S II]', 
      'siii': '[S III]', 
      'oiii': '[O III]', 
      'nii': '[N II]', 
      'oi': '[O I]', 
      'ha': r'H$\alpha$', 
  }
  dxy = {
      'siil': (-23, -2),
      'siii': (5, -3),
      'oiii': (-22, 2), 
      'nii': (-23, -2), 
      'oi': (5, -2),
      'ha': (3, -1), 
  }
  dxy2 = {
      'siil': (-23, -2),
      'siii': (5, -3),
      'oiii': (5, -3), 
      'nii': (5, -2), 
      'oi': (-23, -2),
      'ha': (-15, -2), 
  }

  x_by_line = {}
  y_by_line = {}
  xmax, ymax = 6.0, 11.0
  plotfile = 'obs-stats-plot.pdf'
  sns.set_style('whitegrid')
  sns.set_color_codes()

  fig, ax = plt.subplots(1, 1)
  cmap = cm.Accent
  fig.set_size_inches(4, 6)
  ax.plot([0.0, xmax], [0.0, xmax], c='gray', lw=0.5, zorder=0)
  ax.plot([0.0, xmax], [0.0, 2*xmax], c='gray', lw=0.5, zorder=0)
  # First the standard observed sigmas
  t = Table.read('obs-stats.tab', format='ascii.tab')
  t.sort(['emline'])
  ax.scatter(t['sig(pos)'], t['sig(los)'],
             marker='^', c=range(len(t)), cmap=cmap, zorder=2)
  for x, y, s in zip(t['sig(pos)'], t['sig(los)'], t['emline']):
      ax.annotate(labels[s], (x, y), xytext=dxy[s],
                  textcoords='offset points', fontsize='x-small')
  ax.text(2.9, 9.9, r'Moment-derived', fontweight='bold', fontsize='x-small')

  # Then the sigmas calculated from the FWHM
  t2 = Table.read('obs-stats-fwhm.tab', format='ascii.tab')
  t2.sort(['emline'])
  ax.scatter(t2['sig(pos)'], t2['sig(los)'],
             marker='o', c=range(len(t2)), cmap=cmap, zorder=2)
  x, y = t2['sig(pos)'][-1], t2['sig(los)'][-1]
  for x, y, s in zip(t2['sig(pos)'], t2['sig(los)'], t2['emline']):
      ax.annotate(labels[s], (x, y), xytext=dxy2[s],
                  textcoords='offset points', fontsize='x-small')
  ax.text(1.8, 6.7, 'FWHM-derived', fontweight='bold', fontsize='x-small')

  # And finally plot the [O III] AB components from the line fitting
  t3 = Table.read('oiii-3G-AB-stats.tab', format='ascii.tab')
  t3.sort(['emline'])
  ax.scatter(t3['sig(pos)'], t3['sig(los)'],
             marker='D', c=[2.0], vmin=0.0, vmax=len(t)-1, cmap=cmap, zorder=2)
  x, y = t3['sig(pos)'][-1], t3['sig(los)'][-1]
  ax.text(0.7, 5.0, 'Reflection-corrected', fontweight='bold', fontsize='x-small')
  ax.annotate('[O III]', (x, y), 
              xytext=(5, -2),
              textcoords='offset points', fontsize='x-small')

  tt = join(join(t, t2, keys='emline'), t3, keys='emline', join_type='left')
  tx = tt['sig(pos)_1', 'sig(pos)_2', 'sig(pos)']
  ty = tt['sig(los)_1', 'sig(los)_2', 'sig(los)']
  ax.set_color_cycle(cmap(np.linspace(0, 1, len(t))))  
  for xrow, yrow in zip(tx, ty):
      print(list(xrow), list(yrow))
      plt.plot(list(xrow), list(yrow), '-', lw=0.5, zorder=1, alpha=0.7)

  ax.set_xlim(0.0, xmax)
  ax.set_ylim(0.0, ymax)
  ax.set_xlabel('$\\sigma_\\mathrm{pos} ( \\overline{u} )$ : Plane-of-sky dispersion\n of mean line-of-sight velocities, km/s')
  ax.set_ylabel('$\\langle \\sigma_{\\mathrm{los}} \\rangle_\\mathrm{pos}$ : Plane-of-sky mean of line-of-sight velocity dispersion, km/s')
  ax.set_aspect('equal')
  fig.tight_layout()
  fig.savefig(plotfile)

#+END_SRC

#+RESULTS:
[[file:obs-stats-plot.pdf]]


** Graph of SIMULATION plane-of-sky versus line-of-sight sigmas
#+BEGIN_SRC python :results file :return plotfile
  from astropy.table import Table
  import numpy as np
  from matplotlib import pyplot as plt
  from matplotlib import cm
  import seaborn as sns
  from cycler import cycler

  VIEWS = ['xn', 'xp', 'yn', 'yp', 'zn', 'zp']
  PATTERN = '04052012_4-POS-stats-{}-{}.tab'
  EMLINES = ['O35007', 'N26584']
  THERMAL_SIGMA = {'O35007': 2.8, 'N26584': 3.1}

  labels = {
      'siil': '[S II]', 
      'siii': '[S III]', 
      'O35007': '[O III]', 
      'N26584': '[N II]', 
      'oi': '[O I]', 
      'ha': r'H$\alpha$', 
      'xn': '$-x$', 'xp': '$+x$',
      'yn': '$-y$', 'yp': '$+y$',
      'zn': '$-z$', 'zp': '$+z$',
  }

  COLOR_CYCLE1 = cycler(color=['r', 'm', 'y'])
  COLOR_CYCLE2 = cycler(color=['g', 'b', 'c'])
  ALPHA_CYCLE = cycler(alpha=[1, 0.5])
  LW_CYCLE = cycler(lw=[1.0, 1.5])
  STYLE_CYCLE1 = COLOR_CYCLE1 * (ALPHA_CYCLE + LW_CYCLE)
  STYLE_CYCLE2 = COLOR_CYCLE2 * (ALPHA_CYCLE + LW_CYCLE)

  xmax, ymax = 6.0, 11.0
  plotfile = 'sim-stats-plot.pdf'
  sns.set_color_codes("dark")
  sns.set_style('whitegrid')
  fig, ax = plt.subplots(1, 1)
  fig.set_size_inches(4, 6)
  ax.plot([0.0, xmax], [0.0, xmax], c='gray', lw=0.5, zorder=0)
  ax.plot([0.0, xmax], [0.0, 2*xmax], c='gray', lw=0.5, zorder=0)

  for emline, STYLE_CYCLE in zip(EMLINES, [STYLE_CYCLE1, STYLE_CYCLE2]):

      for vv, sty in zip(VIEWS, STYLE_CYCLE):
          print(vv, sty)
          data = Table.read(PATTERN.format(vv, emline), format='ascii.tab')
          # Correct line widths for thermal broadening
          data['vsig'] = np.sqrt(data['vsig']**2 - THERMAL_SIGMA[emline]**2)
          # Exclude early times
          m = data['time'] >= 10
          # Also mask out positive velocities
          mm = data['vmean'] >= 0.0
          data['d vmean'][mm] = np.nan
          m15 = data['time'] == 15
          m25 = data['time'] == 25
          ax.plot(data['d vmean'][m], data['vsig'][m], 
                  label='{} {}'.format(labels[emline], labels[vv]),
                  **sty
          )
          ax.plot(data['d vmean'][m15], data['vsig'][m15], marker='o', ms=3.0, mew=0.0, label='', **sty)
          ax.plot(data['d vmean'][m25], data['vsig'][m25], marker='o', ms=5.0, mew=0.0, label='', **sty)

  ax.legend(fontsize='xx-small', ncol=2, loc='lower right')
  ax.text(0.5, 5, 'Evolution of\nsimulation', fontweight='bold', fontsize='x-small')
  ax.set_xlim(0.0, xmax)
  ax.set_ylim(0.0, ymax)
  ax.set_xlabel('$\\sigma_\\mathrm{pos} ( \\overline{u} )$ : Plane-of-sky dispersion\n of mean line-of-sight velocities, km/s')
  ax.set_ylabel('$\\langle \\sigma_{\mathrm{los}} \\rangle_\\mathrm{pos}$ : Plane-of-sky mean of line-of-sight velocity dispersion, km/s')
  ax.set_aspect('equal')
  fig.tight_layout()
  fig.savefig(plotfile)

#+END_SRC

#+RESULTS:
[[file:sim-stats-plot.pdf]]


** Calculate PDF of surface brightness
First simulations
#+name: emissivity-variation-sim
#+header: :var EMLINE="O35007" TIME=30
#+BEGIN_SRC python :results output
  import numpy as np
  from matplotlib import pyplot as plt
  from matplotlib.colors import PowerNorm
  import seaborn as sns
  from astropy.io import fits

  TEMPLATE = '04052012_4_{:04d}vsum-{}-{}.fits'
  VIEWS = ['xn', 'xp', 'yn', 'yp', 'zn', 'zp']
  LABELS = {
      'xn': '$-x$', 'xp': '$+x$',
      'yn': '$-y$', 'yp': '$+y$',
      'zn': '$-z$', 'zp': '$+z$',
      'O35007': '[O III] $\lambda$5007', 'N26584': '[N II] $\lambda$6583', 
      }
  for vv in VIEWS:
      fn = TEMPLATE.format(TIME, vv, EMLINE)
      s = fits.open(fn)[0].data.ravel()
      mean = s.mean()
      sig = s.std()
      sigw = np.sqrt(np.average((s-mean)**2, weights=s))
      print(EMLINE, TIME, vv, sig/mean, np.std(np.log10(s)), sigw/mean)

#+END_SRC

#+RESULTS: emissivity-variation
: O35007 30 xn 1.7109 1.58125 3.74926
: O35007 30 xp 1.238 1.71702 2.03549
: O35007 30 yn 1.66927 2.2803 3.25964
: O35007 30 yp 1.15266 1.70701 1.78502
: O35007 30 zn 1.23039 2.13863 2.14974
: O35007 30 zp 1.48446 2.17644 2.88916

+ This is far too large - but that is not surprising since the brightness has a very large gradient
+ We should maybe do a radial detrending first

But first, we will try it with th eobservations

#+name: emissivity-variation-obs
#+BEGIN_SRC python :results file :return plotfile
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  from matplotlib.colors import PowerNorm
  import seaborn as sns
  from astropy.io import fits
  from astropy.modeling import models, fitting
  sys.path.append('/Users/will/Work/RubinWFC3/Tsquared')
  from rebin_utils import downsample, oversample

  plotfile = 'bright-hist-obs.pdf'
  EMLINES = ['siil', 'nii', 'ha', 'oiii']
  DATASET = {'siil': 'spm', 'siis': 'spm',
             'siii': 'spm', 'oi': 'spm',
             'ha': 'kpno', 'nii': 'kpno', 'oiii': 'kpno'}
  TEMPLATES = {
      'kpno': '/Users/will/Work/BobKPNO/DOH{}_-040+070.wisomom-sum-xx.fits',
      'spm': '/Users/will/Work/BobKPNO/newmapas/{}_-040+070.wisomom-sum-smooth2d.fits'
  }
  LABELS = {
      'oiii': r'[O III] $\lambda$5007',
      'nii': r'[N II] $\lambda$6583',
      'ha': r'H$\alpha$ $\lambda$6563',
      'siil': r'[S II] $\lambda$6731',
      'siis': r'[S II] $\lambda$6716',
      'siii': r'[S III] $\lambda$6312',
      'oi': r'[O I] $\lambda$6300',
  }

  sns.set_style('whitegrid')
  sns.set_context('talk')
  sns.set_color_codes("deep")
  whitebox = {'facecolor': 'white', 'alpha': 0.7, 'edgecolor': 'none'}
  fitter = fitting.LevMarLSQFitter()
  fig, axes = plt.subplots(2, 2, sharex=True, sharey=True)
  fig.set_size_inches(6, 4)
  for emline, ax in zip(EMLINES, axes.flat):
      fn = TEMPLATES[DATASET[emline]].format(emline)
      s = fits.open(fn)[0].data
      m = (s > 0.0) & np.isfinite(s)
      s /= np.mean(s[m])
      w = np.ones_like(s)
      for n in [2, 4, 8, 16]:
          [s,], m, w = downsample([s,], m, weights=w, mingood=1)

      #ax.hist(s, bins=100, range=[0.0, 5.0], weights=s)
      H, edges, patches = ax.hist(np.log(s[m]), weights=s[m],
                                  normed=True, bins=25, range=[-2.1, 2.1])
      # Calculate bin centers
      x = 0.5*(edges[:-1] + edges[1:])
      # Fit Gaussian 
      g = models.Gaussian1D(amplitude=H.max(), stddev=0.5)
      core = H > 0.3*H.max()
      g = fitter(g, x[core], H[core])
      xx = np.linspace(-2.1, 2.1, 200)
      ax.plot(xx, g(xx), 'orange', lw=2)
      # Calculate equivalent fractional RMS width in linear brightness space
      X = np.exp(xx)
      Xmean = np.average(X, weights=g(xx))
      Xvariance = np.average((X - Xmean)**2, weights=g(xx))
      eps_rms = np.sqrt(Xvariance)/Xmean
      ax.set_xlim(-2.3, 2.3)
      ax.set_ylim(-0.05, 1.05)
      biglabel = (LABELS[emline]
                  + '\n' + r'$\sigma_{\ln(S/S_0)} '
                  + '= {:.2f}$'.format(g.stddev.value))
      ax.text(-2.2, 0.8, biglabel, bbox=whitebox, fontsize='small')
  axes[-1, 0].set_xlabel(r'Surface brightness: $\ln\, (S / S_0)$')
  axes[-1, 0].set_ylabel('Probability density')
  fig.tight_layout()
  fig.savefig(plotfile)

#+END_SRC

#+RESULTS: emissivity-variation-obs
[[file:bright-hist-obs.pdf]]

** What if we were to fit Gaussians instead?
+ This will be easiest to do with the KPNO data, since we can use the original cubes
+ [2016-05-04 Wed]
  + It is very difficult to get the fits to be continuous along the slit
  + So far I have tried two approaches:
    1. Reset the initial parameters to the same values for each pixel
       - This gives terribly noisy results
    2. Use each pixel's fitted parameters as the starting values for the next pixel
       - This works fine for a while, but then we get a bad fit and afterwards it never recovers
  + So I am going to try a *new approach* based on multigridding
    + Use a hierarchy of spatially binned arrays length 1, 2, 4, ..., 1024
      + The first one is the average of the whole slit
      + The second divides it into 2 halves
      + Then in quarters
      + Etcetera, until the last one is the individual full-resolution pixels
    + 
#+BEGIN_SRC python :eval no :tangle vcube-fit-gauss.py
  import numpy as np
  from astropy.modeling import models, fitting
  from astropy.table import Table
  from astropy.io import fits
  from astropy.wcs import WCS
  from astropy import constants as const
  from matplotlib import pyplot as plt
  import seaborn as sn

  class TwoGaussians(models.Gaussian1D
                     + models.Gaussian1D
                     + models.Const1D):
      """A superposition of two Gaussians plus a constant background"""

  class ThreeGaussians(models.Gaussian1D
                       + models.Gaussian1D
                       + models.Gaussian1D
                       + models.Const1D):
      """A superposition of three Gaussians plus a constant"""

  class FourGaussians(models.Gaussian1D
                       + models.Gaussian1D
                       + models.Gaussian1D
                       + models.Gaussian1D
                       + models.Const1D):
      """A superposition of four Gaussians plus a constant"""

  class ThreeGauss_OneLorentz(models.Gaussian1D
                              + models.Gaussian1D
                              + models.Gaussian1D
                              + models.Lorentz1D
                              + models.Const1D):
      """A superposition of three Gaussians plus a Lorentzian plus constant"""

  DATADIR = '/Users/will/Work/BobKPNO/KPNOsiil/'

  t = Table.read(DATADIR + 'jw4.csv',
                 header_start=2, format='ascii.commented_header')

  fitter = fitting.LevMarLSQFitter()
  # fitter = fitting.SLSQPLSQFitter()
  WINDOW = [-50., 100.]


  def fit_setup_3G():
      bounds = {'amplitude_0': (0.0, None),
                'amplitude_1': (0.0, None),
                'amplitude_2': (0.0, None),
                'amplitude_3': (None, None),
                'mean_0': (-10.0, 10.0),
                'mean_1': (15.0, 30.0),
                'mean_2': (20.0, 40.0),
                'stddev_0': (0.0, 5.0),
                'stddev_1': (0.0, 15.0),
                'stddev_2': (0.0, 5.0),
      }
      return ThreeGaussians(
          amplitude_0=40.0, mean_0=0.0, stddev_0=3.0,
          amplitude_1=100.0, mean_1=20.0, stddev_1=10.0,
          amplitude_2=160.0, mean_2=27.0, stddev_2=3.5,
          amplitude_3=2.0, bounds=bounds)

          
  BOUNDS_4G = {'amplitude_0': (0.0, None),
               'amplitude_1': (0.0, None),
               'amplitude_2': (0.0, None),
               'amplitude_3': (0.0, None),
               'amplitude_4': (None, None),
               'mean_0': (-5.0, 15.0),
               'mean_1': (10.0, 27.0),
               'mean_2': (20.0, 35.0),
               'mean_3': (20.0, None),
               'stddev_0': (3.0, 8.0),
               'stddev_1': (3.0, 8.0),
               'stddev_2': (3.0, 6.5),
               'stddev_3': (6.0, 15.0),
  }

  BOUNDS_4G_NARROW = {'amplitude_0': (0.0, None),
                      'amplitude_1': (0.0, None),
                      'amplitude_2': (0.0, None),
                      'amplitude_3': (0.0, None),
                      'amplitude_4': (None, None),
                      'mean_0': (-5.0, 12.0),
                      'mean_1': (12.0, 27.0),
                      'mean_2': (20.0, 35.0),
                      'mean_3': (35.0, None),
                      'stddev_0': (3.0, 5.0),
                      'stddev_1': (3.0, 5.0),
                      'stddev_2': (3.0, 5.0),
                      'stddev_3': (5.0, 7.0),
  }

  BOUNDS_4G_MINIMAL = {'amplitude_0': (0.0, None),
  'amplitude_1': (0.0, None),
                       'amplitude_2': (0.0, None),
                       'amplitude_3': (0.0, None),
                       'amplitude_4': (None, None)
  }

  def fit_setup_4G(bounds=BOUNDS_4G_NARROW):
      """Four Gaussian profile, hand tailored to the average profile"""
      return FourGaussians(
          amplitude_0=40.0, mean_0=4.0, stddev_0=4.0,
          amplitude_1=200.0, mean_1=20.0, stddev_1=4.0,
          amplitude_2=275.0, mean_2=27.0, stddev_2=4.0,
          amplitude_3=50.0, mean_3=38.0, stddev_3=7.0,
          amplitude_4=10.0, bounds=bounds)

  def freeze_widths(model, ncomponents):
      for k in range(ncomponents):
          model[k].stddev.fixed = True

  def fit_setup_4GL():
      """Using a Lorentzian for the scattered component is worse in every way"""
      bounds = {'amplitude_0': (0.0, None),
                'amplitude_1': (0.0, None),
                'amplitude_2': (0.0, None),
                'amplitude_3': (0.0, None),
                'amplitude_4': (None, None),
                'mean_0': (-10.0, 10.0),
                'mean_1': (10.0, 25.0),
                'mean_2': (20.0, 35.0),
                'x_0_3': (25.0, None),
                'stddev_0': (0.0, 5.0),
                'stddev_1': (0.0, 5.0),
                'stddev_2': (0.0, 5.0),
                'stddev_3': (0.0, 30.0),
      }
      return ThreeGauss_OneLorentz(
          amplitude_0=40.0, mean_0=4.0, stddev_0=4.0,
          amplitude_1=200.0, mean_1=20.0, stddev_1=4.0,
          amplitude_2=275.0, mean_2=27.0, stddev_2=4.0,
          amplitude_3=100.0, x_0_3=27.0, fwhm_3=20.0,
          amplitude_4=10.0, bounds=bounds)

  def mean_n_rows(a, n):
      """Take mean of each chunk of `n` rows of array `a`

  Return new array of shape (nrows/n, ncols)

      """
      nrows, _ = a.shape
      nchunks = nrows//n
      # Use array_split instead of vsplit so that it doesn't matter if n
      # doesn't divide nrows exactly
      return np.vstack(np.mean(chunk, axis=0)
                       for chunk in np.array_split(a, nchunks, axis=0))



  # 1024, 512, 226, ..., 2, 1
  binnings = 2**np.arange(10, -1, -1)


  for d in t[30:31]:
      hdu, = fits.open(DATADIR + d['True File'])
      wcs = WCS(hdu.header)
      ny, nv = hdu.data.shape
      wavs = wcs.wcs.crval[0] + (np.arange(nv) + 1 - wcs.wcs.crpix[0])*wcs.wcs.cd[0,0]
      vels = const.c.to('km/s').value*(wavs - d['lamrest'])/d['lamrest'] + d['helio corr']
      i1 = (vels < WINDOW[0]).sum()
      i2 = (vels <= WINDOW[1]).sum()
      v = vels[i1:i2]
      fig, ax = plt.subplots(1, 1)
      data_line = ax.plot([], [])[0]
      fit_line = ax.plot([], [])[0]
      comp_lines = [ax.plot([], [], '--')[0] for _ in [0, 1, 2, 3]]
      ax.set_xlim(*WINDOW)

      # Initial fit parameters
      fit = fit_setup_4G()
      previous_results_table = Table(names=fit.param_names)
      previous_results_table.add_row(fit.parameters)

      # Loop over binnings starting with the coarsest scale
      for nbin in binnings:
          binid = 'bin{:04d}'.format(nbin)

          results_table = Table(names=fit.param_names)

          for j, profile in enumerate(mean_n_rows(hdu.data, nbin)):
              print(binid, j)
              f = profile[i1:i2]
              ax.set_ylim(-0.1*f.max(), 1.1*f.max())
              plotfile = 'FourGaussians/{}-fit-{}-{:04d}.png'.format(d['col0'], binid, j)

              # Start with parameters from coarser binning level
              fit = FourGaussians(*previous_results_table[j//2].as_void(),
                                  bounds=BOUNDS_4G_NARROW)
              freeze_widths(fit, 3)  # let red component have free width
              # Rescale so total flux is correct
              scale = f.sum()/fit(v).sum()
              for k in range(4):
                  fit[k].amplitude *= scale
              # Perform the fitting
              fit = fitter(fit, v, f, acc=1e-5, maxiter=500)
              results_table.add_row(fit.parameters)
              data_line.set_data(v, f)
              fit_line.set_data(v, fit(v))
              for ii, comp_line in enumerate(comp_lines):
                  comp_line.set_data(v, fit[ii](v))
              fig.savefig(plotfile)

          results_table.write(
              'FourGaussians/{}-fit-{}.tab'.format(d['col0'], binid),
              format='ascii.tab'
          )
          previous_results_table = results_table
#+END_SRC


#+BEGIN_SRC python :return plotfile :results file
  from astropy.table import Table
  from matplotlib import pyplot as plt
  import seaborn as sn
  import numpy as np


  nbin = 1
  tabfile = 'FourGaussians/jw4e252spm-fit-bin{:04d}.tab'.format(nbin)
  t = Table.read(tabfile, format='ascii.tab')
  fig, axes = plt.subplots(3, 1, sharex=True)


  NC = 4                          # Number of Gauss components
  quants = ['amplitude', 'mean', 'stddev']
  pixels = (np.arange(len(t)) + 0.5)*nbin  # pixel centers

  # Lists of columns for quantities: v, A, w
  vcols = [t['mean_{}'.format(k)] for k in range(NC)]
  Acols = [t['amplitude_{}'.format(k)] for k in range(NC)]
  wcols = [t['stddev_{}'.format(k)] for k in range(NC)]

  # Stacks of vectors for each quantity
  vstack = np.vstack(vcols)
  wstack = np.vstack(wcols)
  # Flux is amplitude times width
  Fstack = np.vstack(Acols)*wstack

  # Moments over components
  m0 = Fstack.sum(axis=0)
  m1 = (vstack*Fstack).sum(axis=0)
  m2 = np.sum(Fstack*(vstack - m1/m0)**2, axis=0)
  # And mean width so we can back it out
  ww = (wstack*Fstack).sum(axis=0)/m0
  moments = {
      'amplitude': m0/ww,
      'mean': m1/m0,
      'stddev': np.sqrt(m2/m0),
  }
  mlabels = {
      'amplitude': 'Sum of components',
      'mean': 'Component mean',
      'stddev': 'Component sigma',
  }

  # Now the same, but omitting the first and last components
  vstack = vstack[1:-1]
  wstack = wstack[1:-1]
  Fstack = Fstack[1:-1]
  # Moments over components
  m0 = Fstack.sum(axis=0)
  m1 = (vstack*Fstack).sum(axis=0)
  m2 = np.sum(Fstack*(vstack - m1/m0)**2, axis=0)
  # And mean width so we can back it out
  ww = (wstack*Fstack).sum(axis=0)/m0
  core_moments = {
      'amplitude': m0/ww,
      'mean': m1/m0,
      'stddev': np.sqrt(m2/m0),
  }
  core_mlabels = {
      'amplitude': 'Core amplitude',
      'mean': 'Core mean',
      'stddev': 'Core sigma',
  }

  for q, ax in zip(quants, axes):
      for k in range(NC):
          column = '{}_{}'.format(q, k)
          ax.plot(pixels, t[column], label=column, lw=1, alpha=0.5)
      ax.plot(pixels, moments[q], label=mlabels[q])
      ax.plot(pixels, core_moments[q], label=core_mlabels[q])
      ax.legend(fontsize='x-small')
  axes[0].set_yscale('log')
  axes[0].set_ylim(10.0, None)
  axes[-1].set_xlim(0.0, pixels.max()*1.15)
  axes[-1].set_ylim(0.0, None)
  plotfile = tabfile.replace('.tab', '.pdf')
  fig.set_size_inches(15, 10)
  fig.tight_layout()
  fig.savefig(plotfile)
#+END_SRC

#+RESULTS:
[[file:FourGaussians/jw4e252spm-fit-bin0001.pdf]]


** The same but for [O III] slits
#+BEGIN_SRC python :eval no :tangle oiii-fit-gauss.py
  import numpy as np
  from astropy.modeling import models, fitting
  from astropy.table import Table
  from astropy.io import fits
  from astropy.wcs import WCS
  from astropy import constants as const
  from matplotlib import pyplot as plt
  import seaborn as sn

  class ThreeGaussians(models.Gaussian1D
                       + models.Gaussian1D
                       + models.Gaussian1D
                       + models.Const1D):
      """A superposition of three Gaussians plus a constant"""

  DATADIR = '/Users/will/Work/BobKPNO/DOHoiii/'

  t = Table.read(DATADIR + 'th1c.csv',
                 header_start=2, format='ascii.commented_header')

  fitter = fitting.LevMarLSQFitter()
  # fitter = fitting.SLSQPLSQFitter()
  WINDOW = [-50., 100.]

  BOUNDS_3G_NARROW = {'amplitude_0': (0.0, None),
                      'amplitude_1': (0.0, None),
                      'amplitude_2': (0.0, None),
                      'amplitude_3': (None, None),
                      'mean_0': (0.0, 20.0),
                      'mean_1': (15.0, 35.0),
                      'mean_2': (15.0, 40.0),
                      'stddev_0': (3.0, 8.0),
                      'stddev_1': (3.0, 8.0),
                      'stddev_2': (8.0, 18.0),
  }

  def fit_setup_3G(bounds=BOUNDS_3G_NARROW):
      return ThreeGaussians(
          amplitude_0=1000.0, mean_0=15.0, stddev_0=5.,
          amplitude_1=2000.0, mean_1=23.0, stddev_1=5.,
          amplitude_2=300.0, mean_2=35.0, stddev_2=14.0,
          amplitude_3=10.0, bounds=bounds)


  def freeze_widths(model, ncomponents):
      for k in range(ncomponents):
          model[k].stddev.fixed = True

  def mean_n_rows(a, n):
      """Take mean of each chunk of `n` rows of array `a`

  Return new array of shape (nrows/n, ncols)

      """
      nrows, _ = a.shape
      nchunks = nrows//n
      # Use array_split instead of vsplit so that it doesn't matter if n
      # doesn't divide nrows exactly
      return np.vstack(np.mean(chunk, axis=0)
                       for chunk in np.array_split(a, nchunks, axis=0))



  # 512, 226, ..., 2, 1
  binnings = 2**np.arange(9, -1, -1)
  ngauss = 3

  for d in t:
      hdu, = fits.open(DATADIR + d['True File'])
      wcs = WCS(hdu.header)
      ny, nv = hdu.data.shape
      wavs = d['lam0'] + (np.arange(nv) + 1)*d['lamscale']
      vels = const.c.to('km/s').value*(wavs - d['lamrest'])/d['lamrest']
      # Alternatively, get vels directly from the WCS 
      vels2 = wcs.wcs.crval[0] + (np.arange(nv) + 1
                                  - wcs.wcs.crpix[0])*wcs.wcs.get_cdelt()[0]
      assert np.allclose(vels, vels2)
      vels += d['helio corr'] + d['ufiddle']
      i1 = (vels < WINDOW[0]).sum()
      i2 = (vels <= WINDOW[1]).sum()
      v = vels[i1:i2]
      fig, ax = plt.subplots(1, 1)
      data_line = ax.plot([], [])[0]
      fit_line = ax.plot([], [])[0]
      comp_lines = [ax.plot([], [], '--')[0] for _ in range(ngauss)]
      ax.set_xlim(*WINDOW)

      # Initial fit parameters
      fit = fit_setup_3G()
      previous_results_table = Table(names=fit.param_names)
      previous_results_table.add_row(fit.parameters)

      # Loop over binnings starting with the coarsest scale
      for nbin in binnings:
          binid = 'bin{:04d}'.format(nbin)

          results_table = Table(names=fit.param_names)

          for j, profile in enumerate(mean_n_rows(hdu.data, nbin)):
              print(binid, j)
              f = profile[i1:i2]
              ax.set_ylim(-0.1*f.max(), 1.1*f.max())
              plotfile = 'ThreeGaussians/{}-fit-{}-{:04d}.png'.format(d['col0'], binid, j)

              # Start with parameters from coarser binning level
              jprevious = min(j//2, len(previous_results_table) - 1)
              fit = ThreeGaussians(*previous_results_table[jprevious].as_void(), bounds=BOUNDS_3G_NARROW)
              #freeze_widths(fit, 2)  # let red component width vary
              freeze_widths(fit, 3)  # freeze red component too
              # Rescale so total flux is correct
              scale = f.sum()/fit(v).sum()
              for k in range(4):
                  fit[k].amplitude *= scale
              # Perform the fitting
              fit = fitter(fit, v, f, acc=1e-5, maxiter=500)
              results_table.add_row(fit.parameters)
              data_line.set_data(v, f)
              fit_line.set_data(v, fit(v))
              for ii, comp_line in enumerate(comp_lines):
                  comp_line.set_data(v, fit[ii](v))
              fig.savefig(plotfile)

          results_table.write(
              'ThreeGaussians/{}-fit-{}.tab'.format(d['col0'], binid),
              format='ascii.tab'
          )
          previous_results_table = results_table
#+END_SRC

#+name: plot-3g-fit
#+header: :var SLIT_ID="+042" NBIN=1
#+BEGIN_SRC python :return plotfile :results file
  from astropy.table import Table
  from matplotlib import pyplot as plt
  import seaborn as sn
  import numpy as np


  tabfile = 'ThreeGaussians/th1c{}-fit-bin{:04d}.tab'.format(SLIT_ID, NBIN)
  t = Table.read(tabfile, format='ascii.tab')
  fig, axes = plt.subplots(3, 1, sharex=True)


  NC = 3                          # Number of Gauss components
  quants = ['amplitude', 'mean', 'stddev']
  pixels = (np.arange(len(t)) + 0.5)*NBIN  # pixel centers

  # Lists of columns for quantities: v, A, w
  vcols = [t['mean_{}'.format(k)] for k in range(NC)]
  Acols = [t['amplitude_{}'.format(k)] for k in range(NC)]
  wcols = [t['stddev_{}'.format(k)] for k in range(NC)]

  # Stacks of vectors for each quantity
  vstack = np.vstack(vcols)
  wstack = np.vstack(wcols)
  # Flux is amplitude times width
  Fstack = np.vstack(Acols)*wstack

  # Moments over components
  m0 = Fstack.sum(axis=0)
  m1 = (vstack*Fstack).sum(axis=0)
  m2 = np.sum(Fstack*(vstack - m1/m0)**2, axis=0)
  # And mean width so we can back it out
  ww = (wstack*Fstack).sum(axis=0)/m0
  moments = {
      'amplitude': m0/ww,
      'mean': m1/m0,
      'stddev': np.sqrt(m2/m0),
  }
  mlabels = {
      'amplitude': 'Sum of components',
      'mean': 'Component mean',
      'stddev': 'Component sigma',
  }

  # Now the same, but omitting the red component
  vstack = vstack[:-1]
  wstack = wstack[:-1]
  Fstack = Fstack[:-1]
  # Moments over components
  m0 = Fstack.sum(axis=0)
  m1 = (vstack*Fstack).sum(axis=0)
  m2 = np.sum(Fstack*(vstack - m1/m0)**2, axis=0)
  # And mean width so we can back it out
  ww = (wstack*Fstack).sum(axis=0)/m0
  core_moments = {
      'amplitude': m0/ww,
      'mean': m1/m0,
      'stddev': np.sqrt(m2/m0),
  }
  core_mlabels = {
      'amplitude': 'Core amplitude',
      'mean': 'Core mean',
      'stddev': 'Core sigma',
  }

  for q, ax in zip(quants, axes):
      for k in range(NC):
          column = '{}_{}'.format(q, k)
          ax.plot(pixels, t[column], label=column, lw=1, alpha=0.5)
      ax.plot(pixels, moments[q], label=mlabels[q])
      ax.plot(pixels, core_moments[q], label=core_mlabels[q])
      ax.legend(fontsize='x-small')
  axes[0].set_yscale('log')
  axes[0].set_ylim(10.0, 1e5)
  axes[1].set_ylim(0.0, 45.0)
  axes[2].set_ylim(0.0, 15.0)
  axes[-1].set_xlim(0.0, (pixels.max() + 0.5*NBIN)*1.15)
  plotfile = tabfile.replace('.tab', '.pdf')
  fig.set_size_inches(15, 10)
  fig.tight_layout()
  fig.savefig(plotfile)
#+END_SRC

#+RESULTS: plot-3g-fit
[[file:ThreeGaussians/th1c+042-fit-bin0001.pdf]]

#+RESULTS:
[[file:ThreeGaussians/th1c+042-fit-bin0001.pdf]]


+ This worked pretty well, although not perfectly.
+ There are some slits where the majority of fits are good and stable
  + An example is th1c+042 for pixels > 130 or so


#+call: plot-3g-fit(SLIT_ID="+000") :results file

#+RESULTS:
[[file:ThreeGaussians/th1c+000-fit-bin0001.pdf]]

#+call: plot-3g-fit(SLIT_ID="+000", NBIN=2) :results file

#+RESULTS:
[[file:ThreeGaussians/th1c+000-fit-bin0002.pdf]]

#+call: plot-3g-fit(SLIT_ID="+000", NBIN=4) :results file

#+RESULTS:
[[file:ThreeGaussians/th1c+000-fit-bin0004.pdf]]

#+call: plot-3g-fit(SLIT_ID="+000", NBIN=8) :results file

#+RESULTS:
[[file:ThreeGaussians/th1c+000-fit-bin0008.pdf]]


*** Maps and histograms of the reflection-corrected sigmas
+ First we make the maps
#+BEGIN_SRC python :eval no :tangle oiii-3G-stats.py
  import numpy as np
  from astropy.modeling import models, fitting
  from astropy.table import Table
  from astropy.io import fits
  from astropy import constants as const
  from matplotlib import pyplot as plt
  import seaborn as sn

  class ThreeGaussians(models.Gaussian1D
                       + models.Gaussian1D
                       + models.Gaussian1D
                       + models.Const1D):
      """A superposition of three Gaussians plus a constant"""

  DATADIR = '/Users/will/Work/BobKPNO/DOHoiii/'

  t = Table.read(DATADIR + 'th1c.csv',
                 header_start=2, format='ascii.commented_header')
  WINDOW = [-50., 100.]
  NGAUSS = 3

  # Set up dict of arrays to receive the statistics maps
  output_shape = 514, len(t)
  castaneda_components = 'BAC'    # A is the middle one
  mapvars = [
      'mean fit err', 'max fit err',
      'sigma(obs)', 'vmean(obs)', 'flux(obs)',
      'sigma(fit)', 'vmean(fit)',
      'sigma(AB)', 'vmean(AB)',
      'sigma(A)', 'vmean(A)', 'flux(A)',
      'sigma(B)', 'vmean(B)', 'flux(B)',
      'sigma(C)', 'vmean(C)', 'flux(C)',
  ]
  maps = {k: np.empty(output_shape) for k in mapvars}

  def find_mean_std(x, y):
      """Find mean and stddev of y(x)"""
      if y.sum() <= 0.0:
          xm, xvar = np.nan, np.nan
      else:
          xm = np.average(x, weights=y)
          xvar = np.average((x-xm)**2, weights=y)
      return xm, np.sqrt(xvar)

  def sanitize(s):
      return s.replace(' ', '_').replace('(', '_').replace(')', '')

  def save_map_as_fits(label, data):
      fits.PrimaryHDU(data=data).writeto(
          'oiii-3G-' + sanitize(label) + '.fits',
          clobber=True
      )

  # Loop over slits
  for i, d in enumerate(t):
      # Get fits data of PV image
      hdu, = fits.open(DATADIR + d['True File'])
      ny, nv = hdu.data.shape
      # set up windowed velocity array
      wavs = d['lam0'] + (np.arange(nv) + 1)*d['lamscale']
      vels = const.c.to('km/s').value*(wavs - d['lamrest'])/d['lamrest']
      vels += d['helio corr'] + d['ufiddle']
      k1 = (vels < WINDOW[0]).sum()
      k2 = (vels <= WINDOW[1]).sum()
      v = vels[k1:k2]
      fit_tab = Table.read(
          'ThreeGaussians/{}-fit-bin0001.tab'.format(d['col0']),
          format='ascii.tab')
      assert len(fit_tab) == ny
      # loop over pixels along slit
      for j, (profile, fitpars) in enumerate(zip(hdu.data, fit_tab)):
          f = profile[k1:k2]
          fit = ThreeGaussians(*fitpars.as_void())
          # Absolute fractional deviation of fit (normalized by peak value)
          err_fit = np.abs(f - fit(v))/f.max()

          # Stats for observed line
          (maps['vmean(obs)'][j, i],
           maps['sigma(obs)'][j, i]) =  find_mean_std(v, f)
          maps['flux(obs)'][j, i] = f.sum()
          # Stats for full fitted line
          (maps['vmean(fit)'][j, i],
           maps['sigma(fit)'][j, i]) =  find_mean_std(v, fit(v))
          # Stats for core (A+B components)
          (maps['vmean(AB)'][j, i],
           maps['sigma(AB)'][j, i]) =  find_mean_std(v, fit[0:2](v))
          # Stats for each component separately
          for m, ABC in enumerate(castaneda_components):
              (maps['vmean('+ABC+')'][j, i],
               maps['sigma('+ABC+')'][j, i]) =  find_mean_std(v, fit[m](v))
              maps['flux('+ABC+')'][j, i] = np.sum(fit[m](v))

          maps['mean fit err'][j, i] = np.mean(err_fit)
          maps['max fit err'][j, i] = np.max(err_fit)

  # Save all the maps as FITS images
  for _ in maps:
      save_map_as_fits(_, maps[_])
#+END_SRC

+ This took 164 seconds to run on my laptop
+ The sigma(AB) map is the main product
  + The RMS width of the line core (components A + B)
  + It is typically 6-8 km/s
  + Smaller than the total observed sigma of 8-13 km/s
+ Masks to exclude bad fit regions
  + =mean_fit_err= > 0.02 works quite well
  + combined with =sigma_AB= < 5.01
  + Possible also check the A/B flux ratio and exclude pixels where it is too large or too small

#+BEGIN_SRC python :return plotfile :results file
  import numpy as np
  from matplotlib import pyplot as plt
  from matplotlib.colors import PowerNorm
  import seaborn as sns
  from astropy.io import fits
  from astropy.table import Table

  VLIMITS = [-19.0, 19.0]
  WLIMITS = [0.0, 19.0]
  CMAP = 'magma_r'
  NORM = PowerNorm(gamma=0.6)
  EMLINE = 'oiii'
  LABELS = {
      'oiii': r'[O III] $\lambda$5007',
      'nii': r'[N II] $\lambda$6583',
      'ha': r'H$\alpha$ $\lambda$6563',
      'siil': r'[S II] $\lambda$6731',
      'siis': r'[S II] $\lambda$6716',
      'siii': r'[S III] $\lambda$6312',
      'oi': r'[O I] $\lambda$6300',
  }

  THERMAL_SIGMA = {'oiii': 9.0/4, 'nii': 9.0/np.sqrt(14.0), 'ha': 9.0,
                   'siil': 9.0/np.sqrt(32.0), 'siis': 9.0/np.sqrt(32.0), 
                   'siii': 9.0/np.sqrt(32.0), 'oi': 9.0/4}
  FS_SIGMA = {'ha': 3.2}
  sns.set_style('whitegrid')
  sns.set_color_codes("deep")
  fig, ax = plt.subplots(1, 1)

  fn = 'oiii-3G-flux_obs.fits'
  s = fits.open(fn)[0].data.ravel()
  v = fits.open(fn.replace('flux_obs', 'vmean_AB'))[0].data.ravel()
  # Subtract off mean velocity of star cluster
  v -= 25.0
  w = fits.open(fn.replace('flux_obs', 'sigma_AB'))[0].data.ravel()
  # First filter is that raw width is not at min value
  m = w > 5.01

  # Now check the errors in the Gaussian fits
  e = fits.open(fn.replace('flux_obs', 'mean_fit_err'))[0].data.ravel()
  m = m & (e < 0.02)

  # Subtract off instrumental width: 8 km/s FWHM and thermal width
  w = np.sqrt(w**2 - (8/2.355)**2 - THERMAL_SIGMA[EMLINE]**2 - FS_SIGMA.get(EMLINE, 0.0)**2)
  ax.hist2d(v[m], w[m], weights=s[m], bins=50, range=[VLIMITS, WLIMITS], 
            cmap=CMAP, 
            #norm=NORM,
  )
  ax.set_xlabel('Centroid velocity, $\overline{u}$, km/s')
  ax.set_ylabel('RMS line width, $\sigma$, km/s')
  # ax.set_title(LABELS[EMLINE] + ' line core')
  plotfile = 'oiii-3G-AB-hist-vmean-sig.pdf'

  fig.set_size_inches(3, 3)
  fig.tight_layout()
  fig.savefig(plotfile)

  sig_los = np.average(w[m], weights=s[m])
  vmean = np.average(v[m], weights=s[m])
  sig_pos = np.sqrt(np.average((v[m] - vmean)**2, weights=s[m]))
  Table(names=['emline', 'sig(los)', 'sig(pos)', 'V(los)'],
        rows=[['oiii', sig_los, sig_pos, vmean]]
  ).write('oiii-3G-AB-stats.tab', format='ascii.tab')

#+END_SRC

#+RESULTS:
[[file:oiii-3G-AB-hist-vmean-sig.pdf]]


*** Calculating the "instrumental" plane-of-sky variance
+ This is given by the small-scale noise in the velocities
+ Should be subtracted from the structure function values

#+name: dv2-hist
#+header: :var VELTYPE="obs"
#+BEGIN_SRC python :return plotfile :results file
  from astropy.io import fits
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns

  plotfile = 'oiii-dv2_{}.pdf'.format(VELTYPE)
  hdu, = fits.open('oiii-3G-vmean_{}.fits'.format(VELTYPE))

  m = (hdu.data < 30.0 ) & (hdu.data > 15.0 )
  hdu.data[~m] = np.nan

  # First, differences along the slit 
  dv2_y = (hdu.data[1:, :] - hdu.data[:-1, :])**2
  # Second, differences across the slits
  dv2_x = (hdu.data[:, 1:] - hdu.data[:, :-1])**2

  sns.set_color_codes('dark')
  fig, axes = plt.subplots(2, 1, sharex=True, sharey=True)
  for dv2, ax in [dv2_y.ravel(), axes[0]], [dv2_x.ravel(), axes[1]]:
      m = np.isfinite(dv2) & (dv2 > 0.0)
      ax.hist(np.log10(dv2[m]), bins=50, range=[-6.0, 3.0], color='r')
      #ax.set_yscale('log')
      ax.set_ylim(1.0, 5000.0)
      ax.axvline(np.log10(dv2[m].mean()), color='y', ls='--')
      ax.text(0.02, 0.9, 
              r'$\langle\delta u^{2} \rangle =$'
              + '{:.2f}'.format(dv2[m].mean()),
              transform=ax.transAxes
              )
      ax.axvline(np.log10(np.median(dv2[m])), color='y', ls='--')
      ax.text(0.02, 0.8,
              r'median$(\delta u^{2}) =$'
              + '{:.2f}'.format(np.median(dv2[m])),
              transform=ax.transAxes
      )
  axes[0].set_ylabel('Along slit')
  axes[1].set_ylabel('Acrosss slits')
  axes[-1].set_xlabel(r'$\log_{10} (\delta u^{2})$')
  fig.set_size_inches(6, 10)
  fig.tight_layout()
  fig.savefig(plotfile)


#+END_SRC

#+RESULTS: dv2-hist
[[file:oiii-dv2_obs.pdf]]

#+call: dv2-hist(VELTYPE="A") :results file

#+RESULTS:
[[file:oiii-dv2_A.pdf]]

#+call: dv2-hist(VELTYPE="AB") :results file

#+RESULTS:
[[file:oiii-dv2_AB.pdf]]

*** Make files for Jane to calculate structure function
+ We want the velocity of component A, but with a mask applied
+ And expanded in x to give square pixels

#+BEGIN_SRC python
  from astropy.io import fits
  import numpy as np

  hdu, = fits.open('oiii-3G-vmean_A.fits')

  m = np.isfinite(hdu.data) & (hdu.data > 15.01) & (hdu.data < 34.99)

  # Apply mask directly
  hdu.data[~m] = -999.0

  # Pad out by factor of 4 in x
  hdu.data = np.kron(hdu.data, np.ones((1, 4)))

  hdu.writeto('oiii-component-A-centroid.fits', clobber=True)


#+END_SRC

#+RESULTS:
: None

#+BEGIN_SRC sh :results verbatim
rsync -avzP oiii-component-A-centroid.fits magneton:/fs/magneton/other0/will
#+END_SRC

#+RESULTS:
: sending incremental file list
: oiii-component-A-centroid.fits
:           1,256   0%    0.00kB/s    0:00:00        1,584,000 100%   36.82MB/s    0:00:00 (xfr#1, to-chk=0/1)
: 
: sent 249,535 bytes  received 7,610 bytes  11,428.67 bytes/sec
: total size is 1,584,000  speedup is 6.16

** What would the wind do?
:LOGBOOK:
CLOCK: [2016-04-11 Mon 23:19]--[2016-04-12 Tue 08:18] =>  8:59
:END:
+ We see clear evidence of difference betwen the observed and simulation results
+ The observations have larger sigma, and also more negative [O III]
+ In addition, in the observations, sigma tends to increase for negative ubar
  + Which is seldom seen in the simmulations
  + Usually they show the opposite
+ [ ] What about the analytic calculation of the wind cavity?
  + We could repat the calculations, but with the middle bit removed



** And what about the scattering?
:LOGBOOK:
CLOCK: [2016-04-12 Tue 08:18]--[2016-04-12 Tue 08:47] =>  0:29
:END:
+ LOS sigma increases with blueshift in the observations
+ This is exactly what is expected for back-scattering!
  + Larger blueshifts of direct component should produce larger redshifts of the scattered component
+ And is the opposite of what we see in the simulations
+ We can simulate this
  + The direct velocity is u
  + Assume that a certain fraction A is back-scattered with velocity u' = - B u
    + Where B is a constant between 0 and 1 (depends on mean scattering angle)
    + And this only applies to u < 0, since u > 0 will mainly suffer foreground scattering, not background
  + Then work out change to total ubar and \sigma
    + Assume the broadening adds in quadrature
    + It will reduce ubar a bit (hopefully not much)
    + And it will increase sigma (hopefully by a lot)

 


* Structure function slopes from different authors
| Reference  | Ion     | Method |   \sigma^2 | range_1  |        slope_1 | range_2   | slope_2        |
|------------+---------+--------+------+---------+---------------+----------+---------------|
| O'D W 1992 | [O I]   | Mean   |    3 | 6 - 85  |          0.68 | -        | -             |
| Mc Le 2015 | [O I]   | Mean   |    ? | 12 - 66 |           0.0 | -        | -             |
| This paper | [S II]  | Mean   | 5.35 | 7 - 32  |          0.80 |          |               |
| Mc Le 2015 | [S II]  | Mean   |    ? | 12 - 70 |          0.05 | -        | -             |
| This paper | [N II]  | Mean   | 5.62 | 8 - 22  |          0.82 | 22 - 60  |               |
| W O'D 1993 | [S III] | Comp A | 13.8 | 5 - 20  |          0.92 | 20 - 100 | 0.0           |
| This paper | H a     | Mean   | 9.37 | 8 - 22  |          1.17 | 22 - 60  |               |
| Mc Le 2015 | H a     | Mean   |    ? | 19 - 90 |          0.46 | -        | -             |
| This paper | [O III] | Mean   | 10.2 | 8 - 22  |          1.18 | 22 - 60  |               |
| Casta 1988 | [O III] | Comp A | 13.7 | 3 - 15  |          0.86 | 15 - 80  | 0.5           |
| This paper | [O III] | Comp A | 15.3 | 3 - 15  | 0.73 +/- 0.05 | 15 - 80  | 0.44 +/- 0.04 |
| Mc Le 2015 | [O III] | Mean   |    ? | 12 - 70 |          0.29 | -        | -             |


+ Better version without the Mc Leod data
+ And eliminating the slopes in the large-scale regime too,
  + since this is really the flattening of the spectrum for l > l_0
  + They are still there in the other table above, if they are wanted. 

| Reference  | Ion     | Method |   \sigma^2 | range_1 | slope_1 |
|------------+---------+--------+------+--------+--------|
| O'D W 1992 | [O I]   | Mean   |    3 | 6 - 85 |   0.68 |
| This paper | [S II]  | Mean   | 5.35 | 7 - 32 |   0.80 |
| This paper | [N II]  | Mean   | 5.62 | 8 - 22 |   0.82 |
| W O'D 1993 | [S III] | Comp A | 13.8 | 5 - 20 |   0.92 |
| This paper | H a     | Mean   | 9.37 | 8 - 22 |   1.17 |
| This paper | [O III] | Mean   | 10.2 | 8 - 22 |   1.18 |
| Casta 1988 | [O III] | Comp A | 13.7 | 3 - 15 |   0.86 |
| This paper | [O III] | Comp A | 15.3 | 3 - 15 |   0.73 |




** What if we had an uncorrected linear trend
#+BEGIN_SRC python :results file :return plotfile
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns

  smax = 10.0

  s = np.logspace(-1.8, np.log10(smax), 200)
  n = 2./3.
  Cturb = 1.0/(1.0 + s**n)
  Bturb = 2.0*(1.0 - Cturb)
  Bturb_e = 2.0*(1.0 - np.exp(-s))
  Bgrad = (s/smax)**2

  # seeing
  sfwhm = 0.03
  sig = sfwhm / np.sqrt(8.0*np.log(2.0))
  f = np.exp(-0.5*s**2/sig**2)
  seeing = (1.0 - f)**2 / (1.0 + f)**2

  plotfile = 'strucfunc-ideal.pdf'
  sns.set_style('whitegrid')
  sns.set_color_codes("deep")
  
  fig, ax = plt.subplots(1, 1)
  for afac in 0.0, 0.1, 1.0, 2.0:
      # Factor of 0.5 is mean value of cos^2 PA over PA range 0 -> 360
      ax.plot(s, (Bturb + 0.5*afac*Bgrad)*seeing)
  n = 1.0
  Cturb = 1.0/(1.0 + s**n)
  Bturb = 2.0*(1.0 - Cturb)
  ax.plot(s, Bturb*seeing, 'k--', alpha=0.4)
  #ax.plot(s, Bturb_e, 'k--', alpha=0.4)
  ax.axvline(x=sfwhm, ls=':', c='k', alpha=0.3)
  ax.axvline(x=1.0, ls=':', c='k', alpha=0.3)
  ax.axhline(y=2.0, ls=':', c='w', zorder=-10)

  ax.text(0.05, 0.55, r'$m_\mathrm{2D}=\frac{2}{3}$')
  ax.text(0.2, 0.25, '$m_\mathrm{2D}=1$')
  ax.text(sfwhm, 1.2, 'Seeing\nFWHM',
          bbox={'facecolor': 'white', 'alpha': 0.7, 'ec': 'none'},
          ha='center', fontsize='x-small')
  ax.text(1.0, 0.1, 'Correlation\nlength',
          bbox={'facecolor': 'white', 'alpha': 0.7, 'ec': 'none'},
          ha='center', fontsize='x-small')
  ax.set_xscale('log')
  ax.set_yscale('log')
  ax.set_xlim(s.min(), s.max())
  ax.set_ylim(0.05, 3.0)
  ax.set_xlabel(r'Length scale, $l\ /\,l_{\,0}$')
  ax.set_ylabel(r'Structure function, $S(l) = \langle (\Delta v)^{2} \rangle_{l}\ /\, \sigma^{2}_\mathrm{pos}$')

  fig.set_size_inches(4, 4)
  fig.tight_layout()
  fig.savefig(plotfile)
#+END_SRC

#+RESULTS:
[[file:strucfunc-ideal.pdf]]
+ Here we plot a Kolmogorov spectrum: n = 2/3
  + With turbulent correlation length s_0 = 1
  + Plus linear gradients of different strengths
    + Up to a maximum scale of 10 times s_0
+ Also a n=1 spectrum as dashed line
+ What would be effect of seeing at small scales?
  + With no seeing:
    + Comp A @ v = -0.5 x
    + Comp B @ v = +0.5 x
  + With seeing:
    + Each component has a fraction f = exp(-s^2/2 \sigma^2) of the other one added in
    + Comp A @ v = [(-0.5 x) + f (0.5 x)]/(1 + f) = -0.5 x (1-f)/(1+f)
    + Comp B @ v = +0.5 x (1-f)/(1+f)
  + So (\Delta v)^2 is multiplied by [(1-f)/(1+f)]^2
** [S III] velocity dispersion
|        |    V |
|--------+------|
|        | 19.5 |
|        | 24.0 |
|        | 21.1 |
|        | 21.0 |
|        | 19.0 |
|        | 23.8 |
|        | 19.7 |
|        | 17.6 |
|        | 20.0 |
|        | 18.5 |
|        | 15.3 |
|        | 18.6 |
|        | 20.6 |
|        | 15.2 |
|        | 14.1 |
|        | 19.8 |
|        | 12.9 |
|        | 13.9 |
|        | 19.0 |
|        | 20.1 |
|        | 20.8 |
|        | 17.1 |
|        | 19.5 |
|        | 15.4 |
|        | 16.0 |
|        | 23.5 |
|        | 22.8 |
|        | 20.1 |
|        | 20.8 |
|        | 20.9 |
|        | 19.1 |
|        | 15.2 |
|        | 14.0 |
|        | 12.7 |
|        | 11.0 |
|        | 14.7 |
|        | 25.0 |
|        | 25.2 |
|        | 22.4 |
|        | 22.1 |
|        | 16.7 |
|        | 14.4 |
|        | 14.6 |
|        | 12.1 |
|        | 10.4 |
|        | 24.3 |
|        | 23.0 |
|        | 21.8 |
|        | 18.3 |
|        | 18.5 |
|        | 18.3 |
|        | 12.8 |
|        | 24.3 |
|        | 19.6 |
|        | 14.1 |
|        | 15.3 |
|        | 16.0 |
|        | 18.9 |
|        | 18.1 |
|        | 17.5 |
|        | 16.0 |
|--------+------|
| Mean   | 18.3 |
| stddev | 3.68 |
| var    | 13.8 |
#+TBLFM: @63$2=vmean(@I..@II);f1::@64$2=vpsdev(@I..@II);f2::@65$2=vvar(@I..@II);f1



** [O I] velocity dispersion
|        |    V |
|--------+------|
|        | 25.0 |
|        | 26.8 |
|        | 26.3 |
|        | 25.2 |
|        | 24.9 |
|        | 25.9 |
|        | 25.7 |
|        | 24.7 |
|        | 24.2 |
|        | 24.5 |
|        | 22.3 |
|        | 24.1 |
|        | 24.2 |
|        | 26.0 |
|        | 26.0 |
|        | 26.5 |
|        | 24.8 |
|        | 23.4 |
|        | 27.0 |
|        | 25.4 |
|        | 25.5 |
|        | 27.2 |
|        | 27.3 |
|        | 27.9 |
|        | 27.6 |
|        | 25.5 |
|        | 27.4 |
|        | 27.3 |
|        | 26.6 |
|        | 27.2 |
|        | 27.7 |
|        | 26.5 |
|        | 26.4 |
|        | 25.3 |
|        | 25.3 |
|        | 26.2 |
|        | 25.3 |
|        | 27.7 |
|        | 28.4 |
|        | 26.6 |
|        | 27.6 |
|        | 26.7 |
|        | 24.7 |
|        | 23.8 |
|        | 23.9 |
|        | 25.7 |
|        | 27.7 |
|        | 28.7 |
|        | 28.6 |
|        | 27.0 |
|        | 25.2 |
|        | 25.7 |
|        | 23.2 |
|        | 28.4 |
|        | 26.0 |
|        | 24.5 |
|        | 23.1 |
|        | 24.6 |
|        | 26.0 |
|        | 25.5 |
|        | 25.0 |
|        | 25.2 |
|--------+------|
| Mean   | 25.9 |
| Stddev | 1.45 |
| Var    |  2.1 |
#+TBLFM: @64$2=vmean(@I..@II);f1::@65$2=vpsdev(@I..@II);f2::@66$2=vvar(@I..@II);f1



Look at differences between top and bottom 1/3, separated by about 100''

 
| Vtop | Vbot |     dV |  dV^2 |
|------+------+--------+------|
| 25.0 | 27.7 |   -2.7 |  7.3 |
| 26.8 | 28.7 |   -1.9 |  3.6 |
| 26.3 | 28.6 |   -2.3 |  5.3 |
| 25.2 | 27.0 |   -1.8 |  3.2 |
| 24.9 | 25.2 |   -0.3 | 9e-2 |
| 25.9 | 25.7 |    0.2 | 4e-2 |
| 25.7 | 23.2 |    2.5 |  6.3 |
| 24.7 | 28.4 |   -3.7 | 13.7 |
| 24.2 | 26.0 |   -1.8 |  3.2 |
| 24.5 | 24.5 |     0. |  0.0 |
| 22.3 | 23.1 |   -0.8 |  0.6 |
| 24.1 | 24.6 |   -0.5 |  0.3 |
| 24.2 | 26.0 |   -1.8 |  3.2 |
| 26.0 | 25.5 |    0.5 |  0.3 |
| 26.0 | 25.0 |     1. |  1.0 |
| 26.5 | 25.2 |    1.3 |  1.7 |
| 24.8 | 27.7 |   -2.9 |  8.4 |
| 23.4 | 28.7 |   -5.3 | 28.1 |
|------+------+--------+------|
|      |      |   Mean |  4.8 |
|      |      | Median |  3.2 |
#+TBLFM: $3=$1 - $2::$4=$-1**2;f1::@20$3=Mean::@20$4=vmean(@I..@II);f1::@21$3=Median::@21$4=vmedian(@I..@II);f1


+ Do I really want to do this?


* More fun with the simulations

** TODO Look at the rms Mach number
+ Both volume-weighted and emissivity weighted
+ Subtract off the mean velocity
+ This is implemented in [[file:~/Dropbox/cap-post/src/mach-stats.py][file:~/Dropbox/cap-post/src/mach-stats.py]]
  + But we don't do the volume-weighted case since I don't have the ion fractions
+ The results are rather high:
#+BEGIN_EXAMPLE
  will@nil:results-sac$ python /fs/nil/other0/will/cap-post/src/mach-stats.py 04052012_4_0010
  [O III] mean = [1.04, -5.43, -1.03]
  [O III] RMS = 9.54
  [N II] mean = [0.50, -2.90, -1.08]
  [N II] RMS = 11.63
  will@nil:results-sac$ python /fs/nil/other0/will/cap-post/src/mach-stats.py 04052012_4_0015
  [O III] mean = [-1.02, -5.11, 0.13]
  [O III] RMS = 11.29
  [N II] mean = [-0.77, -1.90, -0.32]
  [N II] RMS = 13.07
  will@nil:results-sac$ python /fs/nil/other0/will/cap-post/src/mach-stats.py 04052012_4_0020
  [O III] mean = [-2.28, -4.01, -1.22]
  [O III] RMS = 11.19
  [N II] mean = [-1.32, -1.38, -0.68]
  [N II] RMS = 13.07
  will@nil:results-sac$ python /fs/nil/other0/will/cap-post/src/mach-stats.py 04052012_4_0025
  [O III] mean = [-3.10, -3.28, -2.62]
  [O III] RMS = 10.76
  [N II] mean = [-1.72, -0.81, -0.72]
  [N II] RMS = 12.15
  will@nil:results-sac$ python /fs/nil/other0/will/cap-post/src/mach-stats.py 04052012_4_0030
  [O III] mean = [-3.93, -2.82, -3.71]
  [O III] RMS = 10.51
  [N II] mean = [-1.86, -0.69, -0.97]
  [N II] RMS = 11.69
#+END_EXAMPLE
** TODO Look at the deprojection factor \xi
+ Is it as low as we think it is?
** TODO Look at correlations between density diagnostics
+ Compare 'real' observed density maps from [S II], [O II], [Cl III], etc
+ Also, look at correlation with surface brightness
+ Perhaps rescale to higher densities
+ 

